

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Huggett (1997): Steady States and Transition Paths in Heterogeneous Agent Models &mdash; GDSGE Homepage</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Krusell and Smith (1998): Heterogeneous Agent Models with Aggregate Uncertainty" href="../KS1998/KS1998.html" />
    <link rel="prev" title="Additional Examples" href="../AdditionalExamples.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> GDSGE
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lectures.html">Lectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbc.html">Getting Started - A Simple RBC Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbcIrr.html">An RBC Model with Irreversible Investment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HL1996/HL1996.html">Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Guvenen2009/Guvenen2009.html">Guvenen (2009): Asset Pricing with Heterogeneous IES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bianchi2011/Bianchi2011.html">Bianchi (2011): Sudden Stops in Open Economies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../safe_assets/safe_assets.html">Barro et al. (2017): Safe Assets with Rare Disasters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandemic/GLSW2020.html">Guerrieri et al. (2020): Negative Supply Shocks That Cause Demand Shortages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage/functions.html">Toolbox API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../AdditionalExamples.html">Additional Examples</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Huggett (1997): Steady States and Transition Paths in Heterogeneous Agent Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-model">The Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-gmod-file-and-matlab-file">The gmod File and MATLAB File</a></li>
<li class="toctree-l3"><a class="reference internal" href="#output">Output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../KS1998/KS1998.html">Krusell and Smith (1998): Heterogeneous Agent Models with Aggregate Uncertainty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Mendoza2010/Mendoza2010.html">Mendoza (2010): Sudden Stops with Asset Price Deflation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../KM1997/CaoNie2017.html">Cao and Nie (2017): Amplification and Asymmetry without Collateral Constraint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Cao2018/Cao2018.html">Cao (2018): Speculation and Wealth Distribution under Beliefs Heterogeneity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Cao2020/Cao2020.html">Cao (2020): Continuum versus Finite Agents in Krusell and Smith (1998)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../multi_country_rbc/multi_country_rbc.html">A Multi-country Business Cycle Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ZLB/zlb.html">A New-Keynesian Model with an Occasionally Binding Interest Rate Zero Lower Bound</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ContributedExamples.html">Contributed Examples</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GDSGE</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../AdditionalExamples.html">Additional Examples</a> &raquo;</li>
        
      <li>Huggett (1997): Steady States and Transition Paths in Heterogeneous Agent Models</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="huggett-1997-steady-states-and-transition-paths-in-heterogeneous-agent-models">
<h1>Huggett (1997): Steady States and Transition Paths in Heterogeneous Agent Models<a class="headerlink" href="#huggett-1997-steady-states-and-transition-paths-in-heterogeneous-agent-models" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-model">
<h2>The Model<a class="headerlink" href="#the-model" title="Permalink to this headline">¶</a></h2>
<p>We use the seminal work <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0304393297000251">Huggett (1997)</a> to illustrate
how the toolbox can be used to solve steady states and transition paths of a heterogeneous-agent model.
The example also demonstrates how to conduct non-stochastic simulations using the toolbox,
by keeping track of the distribution function over a refined grid of individual state variables.</p>
<p>Though the toolbox is not designed for solving the equilibrium of this type of model directly,
since the decision problem is characterized by an equation system (the Euler equation</p>
<div class="math notranslate nohighlight">
\[u'(c_t) = \beta \mathbb{E}_t[(1+r_{t+1})u'(c_{t+1})] + \lambda_t,\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda_t\)</span> is the Lagrange multiplier on the borrowing constraint, and the complementary-slackness condition, <span class="math notranslate nohighlight">\(\lambda_t k_{t+1}=0\)</span>) with state transition functions, it readily fits in the toolbox’s general framework.
One just needs an extra fixed-point loop to update the aggregate equilibrium object, which can be coded in MATLAB.
For the one-sector model studied by <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0304393297000251">Huggett (1997)</a>, the steady state aggregate equilibrium object is the aggregate capital stock; the transition path aggregate equilibrium object is the time sequence
of the aggregate capital stock.</p>
<p>We directly define the equilibrium, which covers all the ingredients we need for computing the model. For the full description of the model,
see <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0304393297000251">Huggett (1997)</a> .</p>
<p>A sequential equilibrium is a time sequence of (1) policy functions <span class="math notranslate nohighlight">\(c_{t}(k,e)\)</span>, <span class="math notranslate nohighlight">\(\lambda_t(k,e)\)</span>, <span class="math notranslate nohighlight">\(k'_t(k,e)\)</span>; (2) measures over individual states <span class="math notranslate nohighlight">\(\phi_t\)</span>;
(3) aggregate prices and quantities <span class="math notranslate nohighlight">\(w_t, r_t, K_t\)</span>, s.t.</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(c_t(k,e), \lambda_t(k,e), k_t'(k,e)\)</span> satisfy individuals’ optimality conditions. That is, they solve</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}c_t(k,e)^{-\sigma}=\beta(1+r_{t+1})E[c_{t+1}(k_t'(k,e),e')^{-\sigma} | e] + \lambda_t(k,e),
\\
k_t'(k,e)\lambda_t(k,e)=0, \quad \lambda_t(k,e)\geq0, \quad k_t'(k,e)\geq0,
\\
c_t(k,e)+k_t'(k,e)=k(1+r_t)+w_te.\end{split}\]</div>
<ol class="arabic simple" start="2">
<li><p>Prices are competitively determined and markets clearing:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}r_t = \alpha K_t^{\alpha-1}-\delta
\\
w_t = (1-\alpha) K_t^{\alpha}
\\
K_t = \int k \  \phi_t(dk,de)\end{split}\]</div>
<ol class="arabic simple" start="3">
<li><p><span class="math notranslate nohighlight">\(\phi_t\)</span> are consistent with the transitions implied by policy functions and exogenous shocks.</p></li>
</ol>
<p>A steady-state equilibrium is a sequential equilibrium with time-invariant equilibrium objects.</p>
<p>Notice we have transformed the individual’s optimization problem into first order conditions and complementarity slackness conditions,
which enable us to solve the decision problem with the toolbox.</p>
</div>
<div class="section" id="the-gmod-file-and-matlab-file">
<h2>The gmod File and MATLAB File<a class="headerlink" href="#the-gmod-file-and-matlab-file" title="Permalink to this headline">¶</a></h2>
<p><a class="reference download internal" download="" href="../../_downloads/7ecca3e36a98699d521edbbf25f19aa7/huggett1997.gmod"><code class="xref download docutils literal notranslate"><span class="pre">huggett1997.gmod</span></code></a></p>
<div class="highlight-GDSGE notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% Toolbox options</span>
INTERP_ORDER = 4; ExtrapOrder = 4;
SIMU_RESOLVE = 0; SIMU_INTERP = 1;
SaveFreq = inf; PrintFreq = 100;
TolEq = 1e-6;
<span class="c">% Parameters</span>
<span class="k">parameters</span> beta sigma kMin r w;
beta = 0.96;    <span class="c">% discount factor</span>
sigma = 1.5;    <span class="c">% CRRA coefficient</span>
alpha = 0.36;   <span class="c">% capital share in production</span>
delta = 0.1;    <span class="c">% depreciation rate</span>

<span class="c">% States</span>
<span class="k">var_state</span> k;
kPts = 100;
kMin = 0;
kMax = 20;
kShift = 1e-3;
k = exp(linspace(log(kMin+1e-3),log(kMax+1e-3),kPts)) - 1e-3;

<span class="c">% Shock process in Huggett (1997)</span>
<span class="k">var_shock</span> e;
e = [0.8, 1.2];
<span class="k">shock_num</span> = 2;
<span class="k">shock_trans</span> = [0.5,0.5;0.5,0.5];

<span class="c">% Representative-agent steady state</span>
kSs = ( (1/beta+delta-1) / alpha )^(1/(alpha-1));
<span class="c">% Initial prices</span>
r = alpha*kSs^(alpha-1) - delta;
w = (1-alpha)*kSs^alpha;

<span class="c">% State transition functions</span>
<span class="k">var_interp</span> Evp_interp;
<span class="k">initial</span> Evp_interp (k.*(1+r)+e.*w).^(-sigma);
<span class="c">% Update</span>
Evp_interp = <span class="k">shock_trans</span>*vp;

<span class="c">% Endogenous variables</span>
<span class="k">var_policy</span> k_next lambda;
<span class="k">inbound</span> k_next kMin k.*(1+r)+e.*w;
<span class="k">inbound</span> lambda 0 1.0;

<span class="c">% Other variables</span>
<span class="k">var_aux</span> c vp;
<span class="c">% Used in simulation</span>
<span class="k">var_output</span> c k_next;
var_others kSs alpha delta output_interp_t;

TASK = &#39;ss&#39;;    <span class="c">% Default task, need overwritten</span>
output_interp_t = {};      <span class="c">% Default transition path;</span>
pre_iter;
  <span class="c">% The pre_iter block will be called at the beginning of every policy iteration</span>
  switch TASK
    case &#39;ss&#39;
    case &#39;transition&#39;
      t = T - GNDSGE_Iter + 1;  <span class="c">% Convert forward to backward</span>
      r = r_t(t);
      w = w_t(t);
  end
<span class="k">end;</span>

<span class="k">model;</span>
  budget = k*(1+r) + e*w;
  c = budget - k_next;
  up = c^(-sigma);
  [Evp_future] = GDSGE_INTERP_VEC(shock,k_next);
  euler_residual = -1 + beta*Evp_future/up + lambda;
  vp = up*(1+r);    <span class="c">% Envelope theorem</span>
  
  <span class="k">equations;</span>
    euler_residual;
    lambda*(k_next-kMin);
  <span class="k">end;</span>
<span class="k">end;</span>

post_iter;
  <span class="c">% The post_iter block will be called at the end of every policy iteration</span>
  switch TASK
    case &#39;transition&#39;
      % The following code constructs function approximation for  <span class="k">var_output</span>
      <span class="c">% and stores in IterRslt.output_interp</span>
      OUTPUT_CONSTRUCT_CODE;
      <span class="c">% Store the period-t equilbrium object</span>
      output_interp_t{t} = IterRslt.output_interp;
  end
<span class="k">end;</span>

<span class="k">simulate;</span>
  <span class="k">num_periods</span> = 1;
  <span class="k">num_samples</span> = 10000;
  <span class="k">initial</span> k kSs;    % A place holder
  <span class="k">initial</span> shock 1;  % A place holder
  <span class="k">var_simu</span> c;
  k&#39; = k_next;
<span class="k">end;</span>
</pre></div>
</td></tr></table></div>
<p>The MATLAB file that calls the toolbox codes and manually update equilibrium objects <a class="reference download internal" download="" href="../../_downloads/3561501ad4eb1591eff358e24a7de4f1/main.m"><code class="xref download docutils literal notranslate"><span class="pre">main.m</span></code></a></p>
<div class="highlight-MATLAB notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">%% Solve a WarmUp problem</span>
<span class="n">IterRslt</span> <span class="p">=</span> <span class="n">iter_huggett1997</span><span class="p">;</span>

<span class="c">%% A fixed-point loop to solve the initial steady state</span>
<span class="n">tolEq</span> <span class="p">=</span> <span class="mf">1e-5</span><span class="p">;</span> <span class="n">metric</span> <span class="p">=</span> <span class="nb">inf</span><span class="p">;</span> <span class="n">iter</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">UPDATE_SPEED</span> <span class="p">=</span> <span class="mf">0.01</span><span class="p">;</span>
<span class="n">K</span> <span class="p">=</span> <span class="n">IterRslt</span><span class="p">.</span><span class="n">var_others</span><span class="p">.</span><span class="n">kSs</span><span class="p">;</span>
<span class="n">alpha</span> <span class="p">=</span> <span class="n">IterRslt</span><span class="p">.</span><span class="n">var_others</span><span class="p">.</span><span class="n">alpha</span><span class="p">;</span> <span class="n">delta</span> <span class="p">=</span> <span class="n">IterRslt</span><span class="p">.</span><span class="n">var_others</span><span class="p">.</span><span class="n">delta</span><span class="p">;</span>
<span class="c">% Non-stochastic simulation, prepare distribution grid</span>
<span class="n">kFinePts</span> <span class="p">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">shockPts</span> <span class="p">=</span> <span class="n">IterRslt</span><span class="p">.</span><span class="n">shock_num</span><span class="p">;</span>
<span class="n">kFine</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_state</span><span class="p">.</span><span class="n">k</span><span class="p">),</span><span class="n">max</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_state</span><span class="p">.</span><span class="n">k</span><span class="p">),</span><span class="n">kFinePts</span><span class="p">)</span><span class="o">&#39;</span><span class="p">;</span>
<span class="n">kFineRight</span> <span class="p">=</span> <span class="p">[</span><span class="n">kFine</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">);</span><span class="nb">inf</span><span class="p">];</span>
<span class="p">[</span><span class="n">kFineGrid</span><span class="p">,</span><span class="n">shockGrid</span><span class="p">]</span> <span class="p">=</span> <span class="nb">ndgrid</span><span class="p">(</span><span class="n">kFine</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">shockPts</span><span class="p">);</span>
<span class="c">% Parameters to simulate only one step</span>
<span class="n">simuOptions</span><span class="p">.</span><span class="n">num_periods</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">simuOptions</span><span class="p">.</span><span class="n">num_samples</span> <span class="p">=</span> <span class="nb">numel</span><span class="p">(</span><span class="n">kFineGrid</span><span class="p">);</span>
<span class="n">simuOptions</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">k</span> <span class="p">=</span> <span class="n">kFineGrid</span><span class="p">(:);</span>
<span class="n">simuOptions</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">shock</span> <span class="p">=</span> <span class="n">shockGrid</span><span class="p">(:);</span>
<span class="n">while</span> <span class="s">metric</span> <span class="o">&gt;</span> <span class="n">tolEq</span>
    <span class="c">% Solve at prices implied by current K</span>
    <span class="n">options</span> <span class="p">=</span> <span class="n">struct</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">TASK</span> <span class="p">=</span> <span class="s">&#39;ss&#39;</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">r</span> <span class="p">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">K</span>^<span class="p">(</span><span class="n">alpha</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">w</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">K</span>^<span class="n">alpha</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">WarmUp</span> <span class="p">=</span> <span class="n">IterRslt</span><span class="p">;</span>
    <span class="n">IterRslt</span> <span class="p">=</span> <span class="n">iter_huggett1997</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
 
    <span class="c">% Non-stochastic simulation. Simulate one-step to get the state transition</span>
    <span class="c">% functions over kFine</span>
    <span class="n">SimuRslt</span> <span class="p">=</span> <span class="n">simulate_huggett1997</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">,</span><span class="n">simuOptions</span><span class="p">);</span>
    <span class="c">% Construct the Markov transition implied by policy functions</span>
    <span class="n">kp</span> <span class="p">=</span> <span class="n">SimuRslt</span><span class="p">.</span><span class="n">k</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="n">kpCell</span><span class="p">]</span> <span class="p">=</span> <span class="n">histc</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="p">[</span><span class="n">kFine</span><span class="p">;</span><span class="nb">inf</span><span class="p">]);</span>
    <span class="n">leftWeights</span> <span class="p">=</span> <span class="p">(</span><span class="n">kFineRight</span><span class="p">(</span><span class="n">kpCell</span><span class="p">)</span><span class="o">-</span><span class="n">kp</span><span class="p">)</span> <span class="o">./</span> <span class="p">(</span><span class="n">kFineRight</span><span class="p">(</span><span class="n">kpCell</span><span class="p">)</span><span class="o">-</span><span class="n">kFine</span><span class="p">(</span><span class="n">kpCell</span><span class="p">));</span>
    <span class="n">leftWeights</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&gt;=</span><span class="n">kFinePts</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">rowVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">shockPts</span><span class="o">*</span><span class="n">kFinePts</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>
    <span class="n">transToKp</span> <span class="p">=</span> <span class="n">sparse</span><span class="p">(</span><span class="n">rowVec</span><span class="p">,</span><span class="n">kpCell</span><span class="p">,</span><span class="n">leftWeights</span><span class="p">,</span><span class="n">shockPts</span><span class="o">*</span><span class="n">kFinePts</span><span class="p">,</span><span class="n">kFinePts</span><span class="p">)</span> <span class="k">...</span>
        <span class="o">+</span> <span class="n">sparse</span><span class="p">(</span><span class="n">rowVec</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&lt;</span><span class="n">kFinePts</span><span class="p">),</span><span class="n">kpCell</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&lt;</span><span class="n">kFinePts</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">leftWeights</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&lt;</span><span class="n">kFinePts</span><span class="p">),</span><span class="k">...</span>
        <span class="n">shockPts</span><span class="o">*</span><span class="n">kFinePts</span><span class="p">,</span><span class="n">kFinePts</span><span class="p">);</span>
    <span class="c">% Accomodate the exogenous transition</span>
    <span class="n">transFull</span> <span class="p">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">transToKp</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="c">% Simulate</span>
    <span class="p">[</span><span class="n">stationaryDist</span><span class="p">,</span><span class="o">~</span><span class="p">]</span> <span class="p">=</span> <span class="n">eigs</span><span class="p">(</span><span class="n">transFull</span><span class="o">&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">stationaryDist</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">stationaryDist</span> <span class="o">/</span> <span class="n">sum</span><span class="p">(</span><span class="n">stationaryDist</span><span class="p">(:)),[</span><span class="n">kFinePts</span><span class="p">,</span><span class="n">shockPts</span><span class="p">]);</span>
    <span class="c">% Statistics</span>
    <span class="n">K_new</span> <span class="p">=</span> <span class="n">sum</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">stationaryDist</span><span class="o">.*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">kFine</span><span class="p">,[</span><span class="n">kFinePts</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">));</span>

    <span class="c">% Update</span>
    <span class="n">metric</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">log</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">-</span> <span class="nb">log</span><span class="p">(</span><span class="n">K_new</span><span class="p">));</span>
    <span class="n">iter</span> <span class="p">=</span> <span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;Steady-state iterations: %d, %g\n&#39;</span><span class="p">,</span><span class="n">iter</span><span class="p">,</span> <span class="n">metric</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;===============================\n&#39;</span><span class="p">);</span>
    <span class="n">K</span> <span class="p">=</span> <span class="n">K_new</span><span class="o">*</span><span class="n">UPDATE_SPEED</span> <span class="o">+</span> <span class="n">K</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">UPDATE_SPEED</span><span class="p">);</span>
<span class="n">end</span>

<span class="s">%%</span> <span class="s">Solve</span> <span class="s">the</span> <span class="s">transition</span> <span class="s">path</span>
<span class="n">T</span> <span class="p">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="n">K_t</span> <span class="p">=</span> <span class="n">K</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">T</span><span class="p">);</span>
<span class="n">K_t_new</span> <span class="p">=</span> <span class="n">K</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">T</span><span class="p">);</span>
<span class="n">tolEq</span> <span class="p">=</span> <span class="mf">1e-3</span><span class="p">;</span> <span class="n">metric</span> <span class="p">=</span> <span class="nb">inf</span><span class="p">;</span> <span class="n">iter</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">UPDATE_SPEED</span> <span class="p">=</span> <span class="mf">0.01</span><span class="p">;</span>
<span class="c">% Initial distribution in Huggett (1997)</span>
<span class="n">dist0</span> <span class="p">=</span> <span class="n">stationaryDist</span><span class="p">;</span>
<span class="n">dist0</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span> <span class="p">=</span> <span class="mf">0.2</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="n">kBar</span> <span class="p">=</span> <span class="n">K</span><span class="o">/</span><span class="mf">0.8</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
<span class="n">kBarIndex</span> <span class="p">=</span> <span class="nb">find</span><span class="p">(</span><span class="n">kFine</span><span class="o">&gt;</span><span class="n">kBar</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">dist0</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">kBarIndex</span><span class="p">,:)</span> <span class="p">=</span> <span class="mf">0.8</span> <span class="o">/</span> <span class="nb">numel</span><span class="p">(</span><span class="n">dist0</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">kBarIndex</span><span class="p">,:));</span>
<span class="n">dist0</span><span class="p">(</span><span class="n">kBarIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">,:)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">while</span> <span class="s">metric</span> <span class="o">&gt;</span> <span class="n">tolEq</span>
    <span class="c">% Backward loop</span>
    <span class="n">options</span> <span class="p">=</span> <span class="n">struct</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">TASK</span> <span class="p">=</span> <span class="s">&#39;transition&#39;</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">PrintFreq</span> <span class="p">=</span> <span class="nb">inf</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">MaxIter</span> <span class="p">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">T</span> <span class="p">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">TolEq</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c">% Do not check TolEq</span>
    <span class="n">options</span><span class="p">.</span><span class="n">r_t</span> <span class="p">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">K_t</span><span class="o">.^</span><span class="p">(</span><span class="n">alpha</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">w_t</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">K_t</span><span class="o">.^</span><span class="n">alpha</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">WarmUp</span> <span class="p">=</span> <span class="n">IterRslt</span><span class="p">;</span>  <span class="c">% Start from steady state</span>
    <span class="n">options</span><span class="p">.</span><span class="n">WarmUp</span><span class="p">.</span><span class="n">Iter</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c">% Start with iter 0;</span>
    <span class="n">IterRslt_t</span> <span class="p">=</span> <span class="n">iter_huggett1997</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>

    <span class="c">% Forward simulation</span>
    <span class="n">dist</span> <span class="p">=</span> <span class="n">dist0</span><span class="p">;</span>
    <span class="n">for</span> <span class="s">t=1:1:T</span>
        <span class="n">K_t_new</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">=</span> <span class="n">sum</span><span class="p">(</span><span class="nb">reshape</span><span class="p">(</span><span class="n">dist</span><span class="o">.*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">kFine</span><span class="p">,[</span><span class="n">kFinePts</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[],</span> <span class="mi">1</span><span class="p">));</span>
        <span class="c">% Simulate using period-t policies</span>
        <span class="n">IterRslt</span><span class="p">.</span><span class="n">output_interp</span> <span class="p">=</span> <span class="n">IterRslt_t</span><span class="p">.</span><span class="n">var_others</span><span class="p">.</span><span class="n">output_interp_t</span><span class="p">{</span><span class="n">t</span><span class="p">};</span>
        <span class="n">SimuRslt_t</span> <span class="p">=</span> <span class="n">simulate_huggett1997</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">,</span><span class="n">simuOptions</span><span class="p">);</span>
        <span class="c">% Construct the Markov transition implied by policy functions</span>
        <span class="n">kp</span> <span class="p">=</span> <span class="n">SimuRslt_t</span><span class="p">.</span><span class="n">k</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
        <span class="p">[</span><span class="o">~</span><span class="p">,</span><span class="n">kpCell</span><span class="p">]</span> <span class="p">=</span> <span class="n">histc</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="p">[</span><span class="n">kFine</span><span class="p">;</span><span class="nb">inf</span><span class="p">]);</span>
        <span class="n">leftWeights</span> <span class="p">=</span> <span class="p">(</span><span class="n">kFineRight</span><span class="p">(</span><span class="n">kpCell</span><span class="p">)</span><span class="o">-</span><span class="n">kp</span><span class="p">)</span> <span class="o">./</span> <span class="p">(</span><span class="n">kFineRight</span><span class="p">(</span><span class="n">kpCell</span><span class="p">)</span><span class="o">-</span><span class="n">kFine</span><span class="p">(</span><span class="n">kpCell</span><span class="p">));</span>
        <span class="n">leftWeights</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&gt;=</span><span class="n">kFinePts</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">rowVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">shockPts</span><span class="o">*</span><span class="n">kFinePts</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>
        <span class="n">transToKp</span> <span class="p">=</span> <span class="n">sparse</span><span class="p">(</span><span class="n">rowVec</span><span class="p">,</span><span class="n">kpCell</span><span class="p">,</span><span class="n">leftWeights</span><span class="p">,</span><span class="n">shockPts</span><span class="o">*</span><span class="n">kFinePts</span><span class="p">,</span><span class="n">kFinePts</span><span class="p">)</span> <span class="k">...</span>
            <span class="o">+</span> <span class="n">sparse</span><span class="p">(</span><span class="n">rowVec</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&lt;</span><span class="n">kFinePts</span><span class="p">),</span><span class="n">kpCell</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&lt;</span><span class="n">kFinePts</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">leftWeights</span><span class="p">(</span><span class="n">kpCell</span><span class="o">&lt;</span><span class="n">kFinePts</span><span class="p">),</span><span class="k">...</span>
            <span class="n">shockPts</span><span class="o">*</span><span class="n">kFinePts</span><span class="p">,</span><span class="n">kFinePts</span><span class="p">);</span>
        <span class="c">% Accomodate the exogenous transition</span>
        <span class="n">transFull</span> <span class="p">=</span> <span class="p">[</span><span class="n">transToKp</span><span class="p">,</span><span class="n">transToKp</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">dist</span> <span class="p">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">dist</span><span class="p">(:)</span><span class="o">&#39;*</span><span class="n">transFull</span><span class="p">,[</span><span class="n">kFinePts</span><span class="p">,</span><span class="n">shockPts</span><span class="p">]);</span>
    <span class="n">end</span>
    
    <span class="s">%</span> <span class="s">Update</span> <span class="s">K_t</span>
    <span class="n">metric</span> <span class="p">=</span> <span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">log</span><span class="p">(</span><span class="n">K_t</span><span class="p">)</span> <span class="o">-</span> <span class="nb">log</span><span class="p">(</span><span class="n">K_t_new</span><span class="p">)));</span>
    <span class="n">iter</span> <span class="p">=</span> <span class="n">iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;Transition path iterations: %d, %g\n&#39;</span><span class="p">,</span><span class="n">iter</span><span class="p">,</span> <span class="n">metric</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="s">&#39;==================================\n&#39;</span><span class="p">);</span>
    <span class="n">if</span> <span class="s">metric&lt;2e-2</span>
        <span class="n">UPDATE_SPEED</span> <span class="p">=</span> <span class="mf">0.03</span><span class="p">;</span>
    <span class="n">end</span>
    <span class="s">K_t</span> <span class="p">=</span> <span class="n">K_t_new</span><span class="o">*</span><span class="n">UPDATE_SPEED</span> <span class="o">+</span> <span class="n">K_t</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">UPDATE_SPEED</span><span class="p">);</span>
<span class="n">end</span>

<span class="s">%%</span> <span class="s">Plot</span>
<span class="n">figure</span><span class="p">;</span> <span class="n">hold</span> <span class="s">on</span><span class="p">;</span>
<span class="n">plot</span><span class="p">(</span><span class="n">K_t</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">500</span><span class="p">),</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mf">1.5</span><span class="p">);</span>
<span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">],[</span><span class="n">K</span><span class="p">,</span><span class="n">K</span><span class="p">],</span><span class="s">&#39;--&#39;</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mf">1.5</span><span class="p">);</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;Transition Path&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;TIME&#39;</span><span class="p">);</span>
<span class="n">legend</span><span class="p">({</span><span class="s">&#39;Equilibrium Path&#39;</span><span class="p">,</span><span class="s">&#39;Steady State Path&#39;</span><span class="p">});</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Aggregate Capital Stock&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="s">&#39;transition_path.png&#39;</span><span class="p">,</span><span class="s">&#39;-dpng&#39;</span><span class="p">);</span>

<span class="n">figure</span><span class="p">;</span> <span class="n">hold</span> <span class="s">on</span><span class="p">;</span>
<span class="n">plot</span><span class="p">(</span><span class="n">kFine</span><span class="p">,</span><span class="n">stationaryDist</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mf">1.5</span><span class="p">);</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;Stationary Distribution&#39;</span><span class="p">);</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">]);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Capital&#39;</span><span class="p">);</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Fractions&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="s">&#39;stationary_dist.png&#39;</span><span class="p">,</span><span class="s">&#39;-dpng&#39;</span><span class="p">);</span>

<span class="n">figure</span><span class="p">;</span> <span class="n">hold</span> <span class="s">on</span><span class="p">;</span>
<span class="n">plot</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_state</span><span class="p">.</span><span class="n">k</span><span class="p">,</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_policy</span><span class="p">.</span><span class="n">k_next</span><span class="p">,</span><span class="s">&#39;LineWidth&#39;</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_state</span><span class="p">.</span><span class="n">k</span><span class="p">,</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_state</span><span class="p">.</span><span class="n">k</span><span class="p">,</span><span class="s">&#39;k-&#39;</span><span class="p">);</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">]);</span>
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">]);</span>
<span class="n">legend</span><span class="p">(</span><span class="s">&#39;a&#39;&#39;(k,0.8)&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;&#39;(k,1.2)&#39;</span><span class="p">,</span><span class="s">&#39;45 Degreee Line&#39;</span><span class="p">,</span><span class="s">&#39;Location&#39;</span><span class="p">,</span><span class="s">&#39;SouthEast&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Capital&#39;</span><span class="p">);</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Capital Next Period&#39;</span><span class="p">);</span>
<span class="n">title</span><span class="p">(</span><span class="s">&#39;Decision Rules for Saving&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="s">&#39;policy_function_kp.png&#39;</span><span class="p">,</span><span class="s">&#39;-dpng&#39;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="output">
<h2>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>The code produces the stationary distribution</p>
<a class="reference internal image-reference" href="../../_images/stationary_dist.png"><img alt="../../_images/stationary_dist.png" src="../../_images/stationary_dist.png" style="width: 437.5px; height: 328.0px;" /></a>
<p>the transition path starting from an equal wealth distribution (see the MATLAB file for how the initial distribution is constructed)</p>
<a class="reference internal image-reference" href="../../_images/transition_path.png"><img alt="../../_images/transition_path.png" src="../../_images/transition_path.png" style="width: 437.5px; height: 328.0px;" /></a>
<p>and the policy functions at the steady state.</p>
<a class="reference internal image-reference" href="../../_images/policy_function_kp.png"><img alt="../../_images/policy_function_kp.png" src="../../_images/policy_function_kp.png" style="width: 437.5px; height: 328.0px;" /></a>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../KS1998/KS1998.html" class="btn btn-neutral float-right" title="Krusell and Smith (1998): Heterogeneous Agent Models with Aggregate Uncertainty" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../AdditionalExamples.html" class="btn btn-neutral float-left" title="Additional Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Dan Cao, Wenlan Luo, and Guangyu Nie

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>