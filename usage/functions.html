<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Toolbox API &mdash; GDSGE Homepage</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Additional Examples" href="../example/AdditionalExamples.html" />
    <link rel="prev" title="A New-Keynesian Model with an Occasionally Binding Interest Rate Zero Lower Bound" href="../example/ZLB/zlb.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> GDSGE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures.html">Lectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/rbc/rbc.html">Getting Started - A Simple RBC Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/simple_zlb/simple_zlb.html">Comparison with OccBin: A Simple Model with an Occasionally Binding Interest Rate ZLB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/rbc/rbcIrr.html">An RBC Model with Irreversible Investment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/HL1996/HL1996.html">Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/Guvenen2009/Guvenen2009.html">Guvenen (2009): Asset Pricing with Heterogeneous IES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/Bianchi2011/Bianchi2011.html">Bianchi (2011): Sudden Stops in Open Economies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/safe_assets/safe_assets.html">Barro et al. (2017): Safe Assets with Rare Disasters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/pandemic/GLSW2020.html">Guerrieri et al. (2020): Negative Supply Shocks That Cause Demand Shortages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/multi_country_rbc/multi_country_rbc.html">A Multi-country Business Cycle Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/ZLB/zlb.html">A New-Keynesian Model with an Occasionally Binding Interest Rate Zero Lower Bound</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Toolbox API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#matlab-interface">MATLAB Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-declaration">Variable declaration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#built-in-functions">Built-in functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#options">Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warm-ups">Warm ups</a></li>
<li class="toctree-l3"><a class="reference internal" href="#policy-iterations">Policy iterations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulation">Simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-approximations">Function approximations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equation-solver">Equation Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#print-and-save">Print and save</a></li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debug">DEBUG</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../example/AdditionalExamples.html">Additional Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../example/ContributedExamples.html">Contributed Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDSGE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Toolbox API</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="toolbox-api">
<h1>Toolbox API<a class="headerlink" href="#toolbox-api" title="Permalink to this heading"></a></h1>
<section id="matlab-interface">
<h2>MATLAB Interface<a class="headerlink" href="#matlab-interface" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="iter_modname">
<span class="sig-name descname"><span class="pre">iter_modname</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#iter_modname" title="Permalink to this definition"></a></dt>
<dd><p>Run policy iterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>options</strong> – a Matlab struct that contains options and parameters to be overwritten.
Notice only options that do not require recompiling can be overwritten. See <a class="reference internal" href="#options"><span class="std std-ref">Options</span></a></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a Matlab struct that contains the structure of the problem and converged policy and state transition functions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="simulate_modname">
<span class="sig-name descname"><span class="pre">simulate_modname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">IterRslt</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#simulate_modname" title="Permalink to this definition"></a></dt>
<dd><p>Simulate models using policy/state transition functions contained in Matlab struct IterRslt.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IterRslt</strong> – results returned by the policy iteration procedure</p></li>
<li><p><strong>options</strong> – a Matlab struct that contains options and parameters to be overwritten.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a Matlab struct that contains simulated panels of variables defined in <cite>var_simu</cite></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="variable-declaration">
<h2>Variable declaration<a class="headerlink" href="#variable-declaration" title="Permalink to this heading"></a></h2>
<dl class="std declare">
<dt class="sig sig-object std" id="declare-parameters-var1-var2-...">
<span class="sig-name descname"><span class="pre">parameters</span> <span class="pre">var1</span> <span class="pre">var2</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-parameters-var1-var2-..." title="Permalink to this definition"></a></dt>
<dd><p>Declare parameters.
Parameters are variables that do not change across states or over time.
A parameter can be a vector. A vector parameter can be accessed in the model block using round brackets. For example,</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="k">parameters</span> var1, var2;
var1 = 1.0;         <span class="c">% Scalar parameter</span>
var2 = [2.0,3.0];   <span class="c">% Vector parameter with two elements</span>
...
<span class="k">model;</span>
    a = var1;       <span class="c">% This assigns a the scalar parameter var1 (1.0)</span>
    b = var2(1);    <span class="c">% This assigns b the first element of parameter var2 (2.0)</span>
    ...
<span class="k">end;</span>
</pre></div>
</div>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_shock-var1-var2-...">
<span class="sig-name descname"><span class="pre">var_shock</span> <span class="pre">var1</span> <span class="pre">var2</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_shock-var1-var2-..." title="Permalink to this definition"></a></dt>
<dd><p>Declare exogenous state variables.
The number of elements of the cartesian set of <cite>var_shock</cite> is specified by <cite>shock_num</cite>.
The full transition matrix is specified by <cite>shock_trans</cite>.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_state-var1-var2-...">
<span class="sig-name descname"><span class="pre">var_state</span> <span class="pre">var1</span> <span class="pre">var2</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_state-var1-var2-..." title="Permalink to this definition"></a></dt>
<dd><p>Declare endogenous state variables.
A fixed grid for each state variable should be defined.
The grid will be used for fixed-grid function approximations such as splines and linear interpolations.
The range of the grid will be used for adaptive grid methods.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_tensor-var1-var2-...">
<span class="sig-name descname"><span class="pre">var_tensor</span> <span class="pre">var1</span> <span class="pre">var2</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_tensor-var1-var2-..." title="Permalink to this definition"></a></dt>
<dd><p>Declare tensor variables that are simple functions of var_shock and var_state.</p>
<p>Some variables are simple functions of var_shock and var_state, and can be evaluated out of the model block.
For example, in the simple RBC model, output needs to enter the resource constraint and is a simple function of
productivity and capital. We can declare output <em>Y</em> as a var_tensor and use it as following:</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="k">parameters</span> alpha;
<span class="k">var_shock</span> z;
<span class="k">var_state</span> K;
<span class="k">var_tensor</span> Y;

... <span class="c">% Definition of z and K here</span>
Y = z.*K.^(alpha); <span class="c">% Assign Y</span>

<span class="k">var_policy</span> c K_next;
inbound c 0 Y;  % <span class="k">var_tensor</span> can be used in inbound
<span class="k">inbound</span> K_next 0 Y;

<span class="k">model;</span>
    resource_residual = Y + (1-delta)*K - c - K_next;
    ...
<span class="k">end;</span>
</pre></div>
</div>
<p>As illustrated above, the advantage of using <a href="#id1"><span class="problematic" id="id2">*</span></a>var_tensor*s and constructing them before the model block is that they can be used to specify the bounds of policy variables, and they are used to avoid redundant evaluations, since these variables are functions of exogenous and endogenous state variables and do not depend on policy variables.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_interp-var1-var2-...">
<span class="sig-name descname"><span class="pre">var_interp</span> <span class="pre">var1</span> <span class="pre">var2</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_interp-var1-var2-..." title="Permalink to this definition"></a></dt>
<dd><p>Declare policy functions from the last iteration to be evaluated in the current iteration.
An initial value should be specified for each <cite>var_interp</cite>.
An update procedure should be specified for each <cite>var_interp</cite> after a policy iteration.
A <cite>var_interp</cite> can be used as a function which take values of <cite>var_state</cite> as arguments in the model block, to evaluate
future policy variables.</p>
<p>Convergence for policy iterations is reached when the maximum absolute difference of <cite>var_interp</cite> between two iterations is smaller than
<em>TolEq</em>.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_policy-var1-var2-len2-...">
<span class="sig-name descname"><span class="pre">var_policy</span> <span class="pre">var1</span> <span class="pre">var2[len2]</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_policy-var1-var2-len2-..." title="Permalink to this definition"></a></dt>
<dd><p>Declare policy variables that directly enter the system of equations.</p>
<p>A <cite>var_policy</cite> can be declared as a vector, for example, var2 of length len2 is declared as <em>var2[len2]</em> in the example.
To access elements of a vector <cite>var_policy</cite> in the model block, use round bracket to index
or use the prime (’) operator to refer to the whole vector.</p>
<p>For each <cite>var_policy</cite>, its lower and upper bounds entering the equation solver should be defined as</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="k">inbound</span> var1 var1_lb var1_ub;
</pre></div>
</div>
<p>If the lower and upper bounds of a <cite>var_policy</cite> cannot be determined ex-ante, specify tight bounds and
use the adaptive bound option such as</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>inbound var1 var1_lb var1_ub <span class="k">adaptive</span>(2.0);
</pre></div>
</div>
<p>This will adjust bounds by expanding the lower and upper bounds by a factor of 2.0 after each policy iteration,
if <cite>UseAdaptiveBound</cite> is set to one. If option <cite>UseAdaptiveBoundInSol</cite> is set to one, after a failed attempt in finding
a solution within the bounds and the equation solver returns a failed solution that hits the lower or upper bound,
the bound will be expanded by a factor of 2.0.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_aux-var1-var2-len2-...">
<span class="sig-name descname"><span class="pre">var_aux</span> <span class="pre">var1</span> <span class="pre">var2[len2]</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_aux-var1-var2-len2-..." title="Permalink to this definition"></a></dt>
<dd><p>Some policy variables of interests are simple functions of <cite>var_state</cite> and <cite>var_policy</cite>, and thus do not need to enter the system of equations
as unknowns. These variables can be declared as <cite>var_aux</cite>.</p>
<p>They need to be evaluated in the model block so as to be returned.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_output-var1-var2-...">
<span class="sig-name descname"><span class="pre">var_output</span> <span class="pre">var1</span> <span class="pre">var2</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_output-var1-var2-..." title="Permalink to this definition"></a></dt>
<dd><p>A subset of <cite>var_policy</cite> or <cite>var_aux</cite> of which the function approximation (such as splines) parameters should be constructed.
These function approximation parameters will be used in simulations if <cite>SIMU_INTERP</cite> is set to one.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-var_others-var1-var2-...">
<span class="sig-name descname"><span class="pre">var_others</span> <span class="pre">var1</span> <span class="pre">var2</span> <span class="pre">...</span></span><a class="headerlink" href="#declare-var_others-var1-var2-..." title="Permalink to this definition"></a></dt>
<dd><p>Any variables in the MATLAB workspace that needs to be returned.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-model-...-end">
<span class="sig-name descname"><span class="pre">model;</span> <span class="pre">...</span> <span class="pre">end;</span></span><a class="headerlink" href="#declare-model-...-end" title="Permalink to this definition"></a></dt>
<dd><p>Declare the model block.</p>
<p>The <em>model;…end;</em> block defines the system of equations for each collocation point of endogenous states and exogenous states.
The equations should be eventually specified in the <em>equation;…end;</em> block, in which each line corresponds to one equation in the system.
Any calculations in order to evaluate these equations are included in the <em>model</em> block preceding the <em>equations</em> block.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-model_init-...-end">
<span class="sig-name descname"><span class="pre">model_init;</span> <span class="pre">...</span> <span class="pre">end;</span></span><a class="headerlink" href="#declare-model_init-...-end" title="Permalink to this definition"></a></dt>
<dd><p>Declare the model_init block.</p>
<p>This is similar to the <em>model;…end;</em> block, but is called only once at the start of the policy iteration.
This is often used to define a last period problem as a starting point of the iteration, which potentially solves a different system of equations.</p>
<p>One can set <em>option:SkipModelInit=1</em> to skip this block, so the policy iteration starts with a WarmUp specified in the option.</p>
</dd></dl>

<dl class="std declare">
<dt class="sig sig-object std" id="declare-simulate-...-end">
<span class="sig-name descname"><span class="pre">simulate;</span> <span class="pre">...</span> <span class="pre">end;</span></span><a class="headerlink" href="#declare-simulate-...-end" title="Permalink to this definition"></a></dt>
<dd><p>Declare the simulation block.</p>
<p>The simulation block should define the initial exogenous state index and endogenous states (e.g. var1 and var2) as follows:</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="k">initial</span> shock 1;
<span class="k">initial</span> var1 some_value1;
<span class="k">initial</span> var2 some_value2;
</pre></div>
</div>
<p>The simulation block should declare the transition of each endogenous variable as follows:</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>var1&#39; = some_variable1;
var2&#39; = some_variable2;
</pre></div>
</div>
<p>If the transition of an endogenous variable is given by indexing a vector <cite>var_policy</cite> or <cite>var_aux</cite> with the future exogenous state index,
specify the transition as follows:</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>var1&#39; = some_<span class="k">var_policy</span>&#39;;
var2&#39; = some_aux_policy&#39;;
</pre></div>
</div>
<p>The simulate block should declare variables to be recorded following keyword <cite>var_simu</cite>.
A <cite>var_simu</cite> must be contained in <cite>var_policy</cite> or <cite>var_aux</cite> if SIMU_RESOLVE=1, or must be contained in <cite>var_output</cite> if SIMU_INTERP=1.</p>
<p>The simulate block can overwrite options num_samples (default 1) and num_periods (default 1000).</p>
</dd></dl>

</section>
<section id="built-in-functions">
<h2>Built-in functions<a class="headerlink" href="#built-in-functions" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GDSGE_INTERP_VEC[vec_index](shock,</span> <span class="pre">var_state1,</span> <span class="pre">var_state2,</span> <span class="pre">...)</span></span></dt>
<dd><p>Return each <em>var_interp</em> evaluated at (var_state1, var_state2, …) for the exogenous shock index referred by argument <em>shock</em>,
according to the order defined in <em>var_interp</em>. For example,</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>...
<span class="k">var_shock</span> z;
<span class="k">var_state</span> x1 x2;
<span class="k">var_interp</span> y1 y2 y3;
...
<span class="k">model;</span>
    x1_future = z;
    x2_future = z^2;
    [y1_future,y2_future,y3_future] = <span class="k">GDSGE_INTERP_VEC</span>(shock,x1_future,x2_future);
<span class="k">end;</span>
</pre></div>
</div>
<p>The optional <em>vec_index</em> specifies a subset of <em>var_interp</em> to be evaluated. For example, the following skips the evaluation of y2.</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>...
    [y1_future,y3_future] = <span class="k">GDSGE_INTERP_VEC</span>[1,3](shock,x1_future,x2_future);
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shock</strong> – the index of exogenous state at which the evaluation is done. Keyword <em>shock</em> refers to the index at the current collocation point.</p></li>
<li><p><strong>var_state</strong> – values of endogenous states</p></li>
<li><p><strong>vec_index</strong> – matlab integer vector that specifies the index of <em>var_interp</em> to be evaluated and returned.
Return all <em>var_interp</em> if omitted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GDSGE_INTERP_VEC'[vec_index](var_state1,</span> <span class="pre">var_state2,</span> <span class="pre">...)</span></span></dt>
<dd><p>Return each <em>var_interp</em> evaluated at (var_state1, var_state2, …) for each realization of exogenous states,
returned according to the order defined in <em>var_interp</em>. The returned results should be assigned to a vector of variables (i.e., variables followed by a prime (‘)).
For example,</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>...
<span class="k">shock_num</span> = 2;
<span class="k">var_shock</span> z;
<span class="k">var_state</span> x1 x2;
<span class="k">var_interp</span> y1 y2 y3;
...
<span class="k">model;</span>
    x1_future&#39; = z&#39;;
    x2_future&#39; = z&#39;^2;
    [y1_future&#39;,y2_future&#39;,y3_future&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>(x1_future&#39;,x2_future&#39;);
<span class="k">end;</span>
</pre></div>
</div>
<p>The line with <em>GDSGE_INTERP_VEC’</em> is equivalent to calling</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>[y1_future(1),y2_future(1),y3_future(1)] = <span class="k">GDSGE_INTERP_VEC</span>(1,x1_future(1),x2_future(1));
[y1_future(2),y2_future(2),y3_future(2)] = <span class="k">GDSGE_INTERP_VEC</span>(2,x1_future(2),x2_future(2));
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_state</strong> – values of endogenous states</p></li>
<li><p><strong>vec_index</strong> – matlab integer vector that specifies the index of <em>var_interp</em> to be evaluated and returned.
Return all <em>var_interp</em> if omitted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GDSGE_EXPECT{expression</span> <span class="pre">|</span> <span class="pre">trans_matrix=shock_trans}</span></span></dt>
<dd><p>Calculate the conditional expectation of an expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expression</strong> – mathematical expression to be calculated</p></li>
<li><p><strong>trans_matrix</strong> – the Markov transition matrix used to form conditional probability. The default value is <em>shock_trans</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GDSGE_MAX{expression}</span></span></dt>
<dd><p>Calculate the maximum of expression across all realizations of exogenous states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expression</strong> – mathematical expression to be calculated</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GDSGE_MIN{expression}</span></span></dt>
<dd><p>Calculate the minimum of expression across all realizations of exogenous states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expression</strong> – mathematical expression to be calculated</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Permalink to this heading"></a></h2>
<p>The toolbox supports a set of macros to facilitate developing. The macro is going to be first preprocessed before the file is passed into the parser.</p>
<dl class="std option">
<dt class="sig sig-object std" id="option-define">
<span class="sig-name descname"><span class="pre">#define</span></span><a class="headerlink" href="#option-define" title="Permalink to this definition"></a></dt>
<dd><p>Define a literal that will be replaced in the preprocessing. For example</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>#define N 8
<span class="k">shock_num</span> = 8;
<span class="k">var_policy</span> w1n[N];
</pre></div>
</div>
<p>The block is equivalent to</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="k">shock_num</span> = 8;
<span class="k">var_policy</span> w1n[8];
</pre></div>
</div>
<p>Currently, #define can only appear at the beginning of a gmod file, and cannot be “undefined”.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-for-...-end">
<span class="sig-name descname"><span class="pre">#for</span> <span class="pre">...</span> <span class="pre">#end</span></span><a class="headerlink" href="#option-for-...-end" title="Permalink to this definition"></a></dt>
<dd><p>Define a for block that will be expanded in the preprocessing. For example</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>#define N 3
#for i=1:N
    <span class="k">var_state</span> K_#i;
#end
</pre></div>
</div>
<p>The block expands to</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="k">var_state</span> K_1;
<span class="k">var_state</span> K_2;
<span class="k">var_state</span> K_3;
</pre></div>
</div>
<p>Notice the iterator (<em>i</em> in the example) appears in the block preceded by a #.</p>
<p>This is convenient to write multi-agent models with agents sharing similar problems, or problems with equilibrium conditions that depend on the current
realization of exogenous states. See example <a class="reference internal" href="../example/HL1996/HL1996TFIter.html#hl1996tfiter"><span class="std std-ref">Heaton and Lucas with Transition Function Iterations</span></a>.</p>
<p>Currently the toolbox does not support nested #for loops.</p>
</dd></dl>

</section>
<section id="options">
<h2>Options<a class="headerlink" href="#options" title="Permalink to this heading"></a></h2>
<p>An option named in all caps (e.g., USE_SPLINE) requires recompiling (via a local or remote compiler) when its value is changed.
Other options can be simply specified through a structure to overwrite existing values without recompiling. For example,</p>
<div class="highlight-MATLAB notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">SaveFreq</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">      </span><span class="c">% Change saving frequency in policy iterations</span><span class="w"></span>
<span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">IterRslt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">iter_modname</span><span class="p">(</span><span class="n">options</span><span class="p">);</span><span class="w"></span>
<span class="k">...</span><span class="w"></span>
<span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">num_samples</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">   </span><span class="c">% Change number of sample paths in simulations</span><span class="w"></span>
<span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SimuRslt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simulate_modname</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">,</span><span class="n">options</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<section id="warm-ups">
<h3>Warm ups<a class="headerlink" href="#warm-ups" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-WarmUp">
<span class="sig-name descname"><span class="pre">WarmUp</span></span><a class="headerlink" href="#option-WarmUp" title="Permalink to this definition"></a></dt>
<dd><p>Pass a converged policy iteration solution (returned by the <em>iter</em> file) as the starting point of the policy iteration. For example,</p>
<div class="highlight-MATLAB notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">IterRslt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">iter_modname</span><span class="p">;</span><span class="w">     </span><span class="c">% Solve the initial problem</span><span class="w"></span>
<span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">WarmUp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IterRslt</span><span class="p">;</span><span class="w">   </span><span class="c">% Specify the starting point</span><span class="w"></span>
<span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">alpha</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w">         </span><span class="c">% Change the parameter value</span><span class="w"></span>
<span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">IterRslt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">iter_modname</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="w">     </span><span class="c">% Starting from the previous converged solution (contained in *IterRslt*) and solving under the new parameter</span><span class="w"></span>
</pre></div>
</div>
<p>The WarmUp passed in does not need to be solved over the same grids as the current problem, and thus can be used as starting point to refine
solutions over finer grids. See example <a class="reference internal" href="../example/Mendoza2010/Mendoza2010.html#mendoza2010"><span class="std std-ref">Mendoza (2010)</span></a>.</p>
<p>Default: Empty</p>
</dd></dl>

</section>
<section id="policy-iterations">
<h3>Policy iterations<a class="headerlink" href="#policy-iterations" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-SkipModelInit">
<span class="sig-name descname"><span class="pre">SkipModelInit</span></span><a class="headerlink" href="#option-SkipModelInit" title="Permalink to this definition"></a></dt>
<dd><p>Skip the <cite>model_init</cite> block. Start iterations with <cite>var_interp</cite> in the WarmUp.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-TolEq">
<span class="sig-name descname"><span class="pre">TolEq</span></span><a class="headerlink" href="#option-TolEq" title="Permalink to this definition"></a></dt>
<dd><p>Convergence criterion for the policy iteration. The policy iteration stops when the maximum absolute distance of <em>var_interp</em> across all collocation points between two iterations is smaller than TolEq.
Default: 1e-6</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-MaxIter">
<span class="sig-name descname"><span class="pre">MaxIter</span></span><a class="headerlink" href="#option-MaxIter" title="Permalink to this definition"></a></dt>
<dd><p>Maximum iterations for policy iterations. Default: inf</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-MaxMinorIter">
<span class="sig-name descname"><span class="pre">MaxMinorIter</span></span><a class="headerlink" href="#option-MaxMinorIter" title="Permalink to this definition"></a></dt>
<dd><p>Maximum minor iterations for randomizing initial guesses when solutions are not found. Default: inf</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-UseAdaptiveBound">
<span class="sig-name descname"><span class="pre">UseAdaptiveBound</span></span><a class="headerlink" href="#option-UseAdaptiveBound" title="Permalink to this definition"></a></dt>
<dd><p>Activate the adaptive bound procedure after each policy iteration. For example, when <em>UseAdaptiveBound</em> is set to one,
the inbound derivative specified as following</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>inbound x 0.0 1.0 <span class="k">adaptive</span>(2);
</pre></div>
</div>
<p>expands the lower and upper bounds by a factor of 2 from the converged solutions of each collocation point, after each policy iteration.</p>
<p>Takes value 0 or 1 (default).</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-UseAdaptiveBoundInSol">
<span class="sig-name descname"><span class="pre">UseAdaptiveBoundInSol</span></span><a class="headerlink" href="#option-UseAdaptiveBoundInSol" title="Permalink to this definition"></a></dt>
<dd><p>Use adaptive bound in randomization after a failed search of solutions within the current bounds, and the search fails at an immature step that hits the current bounds.
Takes value 0 (default) or 1.</p>
</dd></dl>

</section>
<section id="simulation">
<h3>Simulation<a class="headerlink" href="#simulation" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-SIMU_RESOLVE">
<span class="sig-name descname"><span class="pre">SIMU_RESOLVE</span></span><a class="headerlink" href="#option-SIMU_RESOLVE" title="Permalink to this definition"></a></dt>
<dd><p>Whether resolving the system of equations in simulations.
Takes value of 0 or 1 (default).
Only one of <cite>SIMU_RESOLVE</cite> and <cite>SIMU_INTERP</cite> can take value one.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-SIMU_INTERP">
<span class="sig-name descname"><span class="pre">SIMU_INTERP</span></span><a class="headerlink" href="#option-SIMU_INTERP" title="Permalink to this definition"></a></dt>
<dd><p>Whether directly interpolating the policy and state transition functions in simulations.
Takes value of 0 (default) or 1.
Only one of <cite>SIMU_RESOLVE</cite> and <cite>SIMU_INTERP</cite> can take value one.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-SimuSeed">
<span class="sig-name descname"><span class="pre">SimuSeed</span></span><a class="headerlink" href="#option-SimuSeed" title="Permalink to this definition"></a></dt>
<dd><p>The seed for random number generators in simulations. Default: 0823.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-EnforceSimuStateInbound">
<span class="sig-name descname"><span class="pre">EnforceSimuStateInbound</span></span><a class="headerlink" href="#option-EnforceSimuStateInbound" title="Permalink to this definition"></a></dt>
<dd><p>Whether enforcing endogenous states are inbound for each period, after interpolating state transition functions.
Effective only when <cite>SIMU_INTERP</cite> = 1.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-num_samples">
<span class="sig-name descname"><span class="pre">num_samples</span></span><a class="headerlink" href="#option-num_samples" title="Permalink to this definition"></a></dt>
<dd><p>Number of sample paths. Default: 1</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-num_periods">
<span class="sig-name descname"><span class="pre">num_periods</span></span><a class="headerlink" href="#option-num_periods" title="Permalink to this definition"></a></dt>
<dd><p>Number of periods of each sample path. Default: 1000</p>
</dd></dl>

</section>
<section id="function-approximations">
<h3>Function approximations<a class="headerlink" href="#function-approximations" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-USE_SPLINE">
<span class="sig-name descname"><span class="pre">USE_SPLINE</span></span><a class="headerlink" href="#option-USE_SPLINE" title="Permalink to this definition"></a></dt>
<dd><p>Whether to use multi-dimensional linear interpolations or cubic splines for function approximations.
Takes value of 0 or 1 (default).</p>
<p>Only one of USE_SPLINE, USE_PCHIP, USE_ASG can be set to one.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-USE_PCHIP">
<span class="sig-name descname"><span class="pre">USE_PCHIP</span></span><a class="headerlink" href="#option-USE_PCHIP" title="Permalink to this definition"></a></dt>
<dd><p>Whether to use shape-preserving cubic interpolations for function approximations.
Takes value of 0 (default) or 1.</p>
<p>Only one of USE_SPLINE, USE_PCHIP, USE_ASG can be set to one.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-USE_ASG">
<span class="sig-name descname"><span class="pre">USE_ASG</span></span><a class="headerlink" href="#option-USE_ASG" title="Permalink to this definition"></a></dt>
<dd><p>Whether to use the adaptive sparse grid method for function approximations.
Takes value of 0 (default) or 1.</p>
<p>Only one of USE_SPLINE, USE_PCHIP, USE_ASG can be set to one.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-INTERP_ORDER">
<span class="sig-name descname"><span class="pre">INTERP_ORDER</span></span><a class="headerlink" href="#option-INTERP_ORDER" title="Permalink to this definition"></a></dt>
<dd><p>Takes value of 2 (default) or 4.
Only effective if USE_SPLINE=1. INTERP_ORDER=2 corresponds to linear interpolation and INTERP_ORDER=4
corresponds to cubic splines with natural end conditions.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-EXTRAP_ORDER">
<span class="sig-name descname"><span class="pre">EXTRAP_ORDER</span></span><a class="headerlink" href="#option-EXTRAP_ORDER" title="Permalink to this definition"></a></dt>
<dd><p>The order of extrapolations when extrapolating a spline.
Takes value of 2 (default) or 4.
Only effective if USE_SPLINE=1 and INTERP_ORDER=4.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-AsgMaxLevel">
<span class="sig-name descname"><span class="pre">AsgMaxLevel</span></span><a class="headerlink" href="#option-AsgMaxLevel" title="Permalink to this definition"></a></dt>
<dd><p>The maximum level used in the adaptive sparse grid method.  Default 10.
Only effective if USE_ASG=1.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-AsgMinLevel">
<span class="sig-name descname"><span class="pre">AsgMinLevel</span></span><a class="headerlink" href="#option-AsgMinLevel" title="Permalink to this definition"></a></dt>
<dd><p>The minimum level used in the adaptive sparse grid method.  Default 4.
Only effective if USE_ASG=1.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-AsgThreshold">
<span class="sig-name descname"><span class="pre">AsgThreshold</span></span><a class="headerlink" href="#option-AsgThreshold" title="Permalink to this definition"></a></dt>
<dd><p>The tolerance for refinement in the adaptive sparse grid method. Default 1e-2.
Only effective if USE_ASG=1.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-AsgOutputMaxLevel">
<span class="sig-name descname"><span class="pre">AsgOutputMaxLevel</span></span><a class="headerlink" href="#option-AsgOutputMaxLevel" title="Permalink to this definition"></a></dt>
<dd><p>The max level used in the adaptive sparse grid method for <cite>var_output</cite>.  Default 10.
Only effective if USE_ASG=1.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-AsgOutputThreshold">
<span class="sig-name descname"><span class="pre">AsgOutputThreshold</span></span><a class="headerlink" href="#option-AsgOutputThreshold" title="Permalink to this definition"></a></dt>
<dd><p>The tolerance for refinement in the adaptive sparse grid method for <cite>var_output</cite>. Default MIN(1e-2, AsgThreshold).
Only effective if USE_ASG=1.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-AsgFixGrid">
<span class="sig-name descname"><span class="pre">AsgFixGrid</span></span><a class="headerlink" href="#option-AsgFixGrid" title="Permalink to this definition"></a></dt>
<dd><p>Whether fix the adaptive grid to the one passed in struct WarmUp.
Takes value of 0 (default) or 1.</p>
</dd></dl>

</section>
<section id="equation-solver">
<h3>Equation Solver<a class="headerlink" href="#equation-solver" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-TolSol">
<span class="sig-name descname"><span class="pre">TolSol</span></span><a class="headerlink" href="#option-TolSol" title="Permalink to this definition"></a></dt>
<dd><p>Absolute residual tolerance in equation solving. Default: 1e-8</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-SolMaxIter">
<span class="sig-name descname"><span class="pre">SolMaxIter</span></span><a class="headerlink" href="#option-SolMaxIter" title="Permalink to this definition"></a></dt>
<dd><p>Maximum number of function evaluations in equation solving. Default: 200</p>
</dd></dl>

</section>
<section id="print-and-save">
<h3>Print and save<a class="headerlink" href="#print-and-save" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-PrintFreq">
<span class="sig-name descname"><span class="pre">PrintFreq</span></span><a class="headerlink" href="#option-PrintFreq" title="Permalink to this definition"></a></dt>
<dd><p>Frequency of printing information in policy iterations</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-SaveFreq">
<span class="sig-name descname"><span class="pre">SaveFreq</span></span><a class="headerlink" href="#option-SaveFreq" title="Permalink to this definition"></a></dt>
<dd><p>Frequency of saving in policy iterations</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-SimuPrintFreq">
<span class="sig-name descname"><span class="pre">SimuPrintFreq</span></span><a class="headerlink" href="#option-SimuPrintFreq" title="Permalink to this definition"></a></dt>
<dd><p>Frequency of printing information in simulations</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-SimuSaveFreq">
<span class="sig-name descname"><span class="pre">SimuSaveFreq</span></span><a class="headerlink" href="#option-SimuSaveFreq" title="Permalink to this definition"></a></dt>
<dd><p>Frequency of saving in simulations</p>
</dd></dl>

</section>
<section id="miscellaneous">
<h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-NumThreads">
<span class="sig-name descname"><span class="pre">NumThreads</span></span><a class="headerlink" href="#option-NumThreads" title="Permalink to this definition"></a></dt>
<dd><p>Number of (OpenMP) threads in policy iterations and simulations.
Default: the number of cores (via Matlab function <code class="docutils literal notranslate"><span class="pre">feature('numcores')</span></code>)</p>
</dd></dl>

</section>
<section id="debug">
<h3>DEBUG<a class="headerlink" href="#debug" title="Permalink to this heading"></a></h3>
<dl class="std option">
<dt class="sig sig-object std" id="option-GDSGE_DEBUG_EVAL_ONLY">
<span class="sig-name descname"><span class="pre">GDSGE_DEBUG_EVAL_ONLY</span></span><a class="headerlink" href="#option-GDSGE_DEBUG_EVAL_ONLY" title="Permalink to this definition"></a></dt>
<dd><p>Only evaluate the system of equations instead of solving it.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="option-IterSaveAll">
<span class="sig-name descname"><span class="pre">IterSaveAll</span></span><a class="headerlink" href="#option-IterSaveAll" title="Permalink to this definition"></a></dt>
<dd><p>Save all variables in the workspace after policy iterations.</p>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../example/ZLB/zlb.html" class="btn btn-neutral float-left" title="A New-Keynesian Model with an Occasionally Binding Interest Rate Zero Lower Bound" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../example/AdditionalExamples.html" class="btn btn-neutral float-right" title="Additional Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Dan Cao, Wenlan Luo, and Guangyu Nie.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>