<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bianchi (2011): Sudden Stops in Open Economies &mdash; GDSGE Homepage</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Barro et al. (2017): Safe Assets with Rare Disasters" href="../safe_assets/safe_assets.html" />
    <link rel="prev" title="Guvenen (2009): Asset Pricing with Heterogeneous IES" href="../Guvenen2009/Guvenen2009.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GDSGE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lectures.html">Lectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbc.html">Getting Started - A Simple RBC Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simple_zlb/simple_zlb.html">Comparison with OccBin: A Simple Model with an Occasionally Binding Interest Rate ZLB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbcIrr.html">An RBC Model with Irreversible Investment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HL1996/HL1996.html">Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Guvenen2009/Guvenen2009.html">Guvenen (2009): Asset Pricing with Heterogeneous IES</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Bianchi (2011): Sudden Stops in Open Economies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-model">The Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-gmod-file">The gmod File</a></li>
<li class="toctree-l2"><a class="reference internal" href="#results">Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-planner-s-solution">The Planner’s solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-s-next">What’s Next?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../safe_assets/safe_assets.html">Barro et al. (2017): Safe Assets with Rare Disasters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandemic/GLSW2020.html">Guerrieri et al. (2022): Negative Supply Shocks That Cause Demand Shortages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../multi_country_rbc/multi_country_rbc.html">A Multi-country Business Cycle Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ZLB/zlb.html">A New-Keynesian Model with an Occasionally Binding Interest Rate Zero Lower Bound</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage/functions.html">Toolbox API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdditionalExamples.html">Additional Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ContributedExamples.html">Contributed Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GDSGE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Bianchi (2011): Sudden Stops in Open Economies</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="bianchi-2011-sudden-stops-in-open-economies">
<h1>Bianchi (2011): Sudden Stops in Open Economies<a class="headerlink" href="#bianchi-2011-sudden-stops-in-open-economies" title="Permalink to this heading"></a></h1>
<p>The benchmark model in <a class="reference external" href="https://www.aeaweb.org/articles?id=10.1257/aer.101.7.3400">Bianchi (2011)</a> provides an example in which the economic dynamics can be highly non-linear
due to the presence of a borrowing constraint tied to a (good) price. We illustrate how to use the adaptive grid method
with the toolbox to capture the non-linearity effectively. This example also introduces how to solve the model in a coarse and narrow grid of the state space,
and then refine the state space to ensure it covers the ergodic set by reusing the compiled code.</p>
<section id="the-model">
<span id="bianchi2011"></span><h2>The Model<a class="headerlink" href="#the-model" title="Permalink to this heading"></a></h2>
<p><a class="reference external" href="https://www.aeaweb.org/articles?id=10.1257/aer.101.7.3400">Bianchi (2011)</a> studies an incomplete-markets open economy model that can generate competitive equilibria featuring sudden stop episodes,
resembling those experienced by many emerging economies.
A sudden stop episode features a large output drop and current account reversals,
which are at odds with the prediction of a standard incomplete-markets model with precautionary saving motives.
A key feature for the model in <a class="reference external" href="https://www.aeaweb.org/articles?id=10.1257/aer.101.7.3400">Bianchi (2011)</a>
is to introduce feedback of the  price of non-tradable goods to the borrowing constraint: a negative external shock
that lowers the equilibrium price of non-tradable goods tightens the borrowing constraint and forces reducing the consumption of tradable goods,
which further lowers the price of non-tradable goods.
The competitive equilibrium is inefficient since agents do not take into account the effects of their consumption on the non-tradable price and the borrowing constraint.
This leads to ex-ante over-borrowing and calls for policy interventions.</p>
<p>The borrowing constraint is occasionally binding in the equilibrium’s ergodic set,
and the equilibrium policy and state transition functions are highly non-linear when the borrowing constraint binds.
Therefore, a global and non-linear solution is essential to capture the model’s rich dynamics. We solve the competitive equilibrium of the benchmark model in
<a class="reference external" href="https://www.aeaweb.org/articles?id=10.1257/aer.101.7.3400">Bianchi (2011)</a>, described below.</p>
<p>Small-open economy representative consumers derive utility from consumption of tradable goods  <span class="math notranslate nohighlight">\(c_t^T\)</span> and of non-tradable goods <span class="math notranslate nohighlight">\(c_t^N\)</span> according to</p>
<div class="math notranslate nohighlight">
\[\begin{split}&amp; \mathbb E \Big\{\sum_{t=0}^{\infty} \beta^t u(c_t)\Big\}
\\
s.t. \quad
&amp; c_t = [\omega (c_t^T)^{-\eta} + (1-\omega)(c_t^N)^{-\eta}]^{-\frac{1}{\eta}}
, \eta &gt; -1, \omega \in (0,1)\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega, \eta\)</span> are parameters. <span class="math notranslate nohighlight">\(\beta\in(0,1)\)</span> is the discount factor. <span class="math notranslate nohighlight">\(\mathbb{E}\)</span>  is the expectation operator to integrate shocks below.</p>
<p>Borrowing is via a state non-contingent bond in tradable goods at a constant world interest <span class="math notranslate nohighlight">\(r\)</span>.
The endowments of tradable goods <span class="math notranslate nohighlight">\(y_t^T\)</span> and non-tradable goods <span class="math notranslate nohighlight">\(y_t^N\)</span> follow exogenous stochastic processes. The consumer faces the following sequential budget constraint</p>
<div class="math notranslate nohighlight">
\[b_{t+1} + c_t^T + p_t^N c_t^N = b_t(1+r) + y_t^T + p_t^Ny_t,\]</div>
<p>where <span class="math notranslate nohighlight">\(b_{t+1}\)</span> is the bond-holding determined at period <span class="math notranslate nohighlight">\(t\)</span>. Tradable good is the numeraire and <span class="math notranslate nohighlight">\(p_t^N\)</span> is the equilibrium price of non-tradable goods, taken as given by consumers.</p>
<p>A key feature of the model is that the borrowing is subject to a borrowing constraint tied to the non-tradable good price as below</p>
<div class="math notranslate nohighlight">
\[b_{t+1} \geq - (\kappa^N p_t^N y_t^N + \kappa^T y_t^T)\]</div>
<p>which says that the borrowing cannot exceed the sum of <span class="math notranslate nohighlight">\(\kappa^N\)</span> fraction of the value of non-tradable goods,
plus <span class="math notranslate nohighlight">\(\kappa^T\)</span> fraction of the value of tradable goods, with parameter
<span class="math notranslate nohighlight">\(\kappa^N&gt;0, \kappa^T&gt;0\)</span> determining the collaterability of the non-tradable and tradable endowments, respectively.</p>
<p>A sequential competitive equilibrium is stochastic sequences <span class="math notranslate nohighlight">\(\{b_{t+1},c_t^T,c_t^N,c_t,\mu_t,\lambda_t,p_t^N\}_{t=0}^{\infty}\)</span> such that</p>
<ul class="simple">
<li><p>Consumers optimize:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}p_t^N = \Big(\frac{1-\omega}{\omega}\Big)\Big(\frac{c_t^T}{c_t^N}\Big)^{\eta+1},
\\
\lambda_t = \beta(1+r) \mathbb{E}_t \lambda_{t+1} + \mu_t,
\\
\mu_t[b_{t+1} + (\kappa^N p_t^N y_t^N + \kappa^T y_t^T) =0,
\\
b_{t+1} + c_t^T + p_t^N c_t^N = b_t(1+r) + y_t^T + p_t^Ny_t^N,
\\
c_t = [\omega(c_t^T)^{-\eta} + (1-\omega)(c_t^N)^{-\eta}]^{-1/\eta},\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\lambda_t = u'(c_{t}) \frac{\partial c_t}{\partial c_t^T}=u'(c_t)[\omega (c_t^T)^{-\eta} + (1-\omega)(c_t^N)^{-\eta}]^{-\frac{1}{\eta}-1}\omega [c_t^T]^{-\eta-1}.\]</div>
<ul class="simple">
<li><p>Markets clear:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}&amp; c_t^N = y_t^N,
\\
&amp; c_t^T = y_t^T+b_t(1+r)-b_{t+1}.\end{split}\]</div>
<p>Notice that we have replaced the consumer’s constrained optimization problem with
first order conditions and complementarity conditions, which allows us to describe the equilibrium as a system of equilibrium equations.</p>
<p>To input the model into the toolbox, we need to formulate the recursive system.
The exogenous states are <span class="math notranslate nohighlight">\(y_t^N,y_t^T\)</span>, the natural endogenous state is <span class="math notranslate nohighlight">\(b_t\)</span>.
A recursive competitive equilibrium is <span class="math notranslate nohighlight">\(b'(y^N,y^T,b),c^T(y^N,y^T,b),c^N(y^N,y^T,b),c(y^N,y^T,b),\mu(y^N,y^T,b),\lambda(y^N,y^T,b),p^N(y^N,y^T,b)\)</span> that satisfy
the optimization and markets clearing conditions.</p>
</section>
<section id="the-gmod-file">
<h2>The gmod File<a class="headerlink" href="#the-gmod-file" title="Permalink to this heading"></a></h2>
<p>The recursive system can be solved using GDSGE with <a class="reference download internal" download="" href="../../_downloads/b32061ed3d76601106c4dafa0e027ea4/bianchi2011.gmod"><code class="xref download docutils literal notranslate"><span class="pre">bianchi2011.gmod</span></code></a> below</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="c">% Toolbox options</span>
<span class="linenos">  2</span>USE_ASG=1; USE_SPLINE=0;
<span class="linenos">  3</span>AsgMaxLevel = 10;
<span class="linenos">  4</span>AsgThreshold = 1e-4;
<span class="linenos">  5</span>
<span class="linenos">  6</span><span class="c">% Parameters</span>
<span class="linenos">  7</span><span class="k">parameters</span> r sigma eta kappaN kappaT omega beta;
<span class="linenos">  8</span>r = 0.04;
<span class="linenos">  9</span>sigma = 2;
<span class="linenos"> 10</span>eta = 1/0.83 - 1;
<span class="linenos"> 11</span>kappaN = 0.32;
<span class="linenos"> 12</span>kappaT = 0.32;
<span class="linenos"> 13</span>omega = 0.31;
<span class="linenos"> 14</span>beta = 0.91;
<span class="linenos"> 15</span>
<span class="linenos"> 16</span><span class="c">% States</span>
<span class="linenos"> 17</span><span class="k">var_state</span> b;
<span class="linenos"> 18</span>bPts = 101;
<span class="linenos"> 19</span>bMin=-0.5;
<span class="linenos"> 20</span>bMax=0.0;
<span class="linenos"> 21</span>b=linspace(bMin,bMax,bPts);
<span class="linenos"> 22</span>
<span class="linenos"> 23</span><span class="c">% Shocks</span>
<span class="linenos"> 24</span><span class="k">var_shock</span> yT yN;
<span class="linenos"> 25</span>yPts = 4;
<span class="linenos"> 26</span><span class="k">shock_num</span>=16;
<span class="linenos"> 27</span>
<span class="linenos"> 28</span>yTEpsilonVar = 0.00219;
<span class="linenos"> 29</span>yNEpsilonVar = 0.00167;
<span class="linenos"> 30</span>rhoYT = 0.901;
<span class="linenos"> 31</span>rhoYN = 0.225;
<span class="linenos"> 32</span>
<span class="linenos"> 33</span>[yTTrans,yT] = markovappr(rhoYT,yTEpsilonVar^0.5,1,yPts);
<span class="linenos"> 34</span>[yNTrans,yN] = markovappr(rhoYN,yNEpsilonVar^0.5,1,yPts);
<span class="linenos"> 35</span>
<span class="linenos"> 36</span><span class="k">shock_trans</span> = kron(yNTrans,yTTrans);
<span class="linenos"> 37</span>[yT,yN] = ndgrid(yT,yN);
<span class="linenos"> 38</span>yT = exp(yT(:)&#39;);
<span class="linenos"> 39</span>yN = exp(yN(:)&#39;);
<span class="linenos"> 40</span>
<span class="linenos"> 41</span><span class="c">% Define the last-period problem</span>
<span class="linenos"> 42</span><span class="k">var_policy</span>_init dummy;
<span class="linenos"> 43</span><span class="k">inbound</span>_init dummy -1.0 1.0;
<span class="linenos"> 44</span>
<span class="linenos"> 45</span><span class="k">var_aux</span>_init c lambda;
<span class="linenos"> 46</span><span class="k">model_init;</span>
<span class="linenos"> 47</span>  cT = yT + b*(1+r);
<span class="linenos"> 48</span>  cN = yN;
<span class="linenos"> 49</span>  c = (omega*cT^(-eta) + (1-omega)*cN^(-eta))^(-1/eta);
<span class="linenos"> 50</span>  partial_c_partial_cT = (omega*cT^(-eta) + (1-omega)*cN^(-eta))^(-1/eta-1) * omega * cT^(-eta-1);
<span class="linenos"> 51</span>  lambda = c^(-sigma)*partial_c_partial_cT;
<span class="linenos"> 52</span>  
<span class="linenos"> 53</span>  <span class="k">equations;</span>
<span class="linenos"> 54</span>    0;
<span class="linenos"> 55</span>  <span class="k">end;</span>
<span class="linenos"> 56</span><span class="k">end;</span>
<span class="linenos"> 57</span>
<span class="linenos"> 58</span><span class="c">% Implicit state transition functions</span>
<span class="linenos"> 59</span><span class="k">var_interp</span> lambda_interp;
<span class="linenos"> 60</span><span class="k">initial</span> lambda_interp lambda;
<span class="linenos"> 61</span>lambda_interp = lambda;
<span class="linenos"> 62</span>
<span class="linenos"> 63</span><span class="c">% Endogenous variables, bounds, and initial values</span>
<span class="linenos"> 64</span><span class="k">var_policy</span> nbNext mu cT pN;
<span class="linenos"> 65</span><span class="k">inbound</span> nbNext 0.0 10.0;
<span class="linenos"> 66</span><span class="k">inbound</span> mu 0.0 1.0;
<span class="linenos"> 67</span><span class="k">inbound</span> cT 0.0 10.0;
<span class="linenos"> 68</span><span class="k">inbound</span> pN 0.0 10.0;
<span class="linenos"> 69</span>
<span class="linenos"> 70</span><span class="k">var_aux</span> c lambda bNext;
<span class="linenos"> 71</span><span class="k">var_output</span> bNext pN;
<span class="linenos"> 72</span>
<span class="linenos"> 73</span><span class="k">model;</span>
<span class="linenos"> 74</span>  <span class="c">% Non tradable market clear</span>
<span class="linenos"> 75</span>  cN = yN;
<span class="linenos"> 76</span>
<span class="linenos"> 77</span>  <span class="c">% Transform variables</span>
<span class="linenos"> 78</span>  bNext = nbNext - (kappaN*pN*yN + kappaT*yT);
<span class="linenos"> 79</span>  <span class="c">% Interp future values</span>
<span class="linenos"> 80</span>  lambdaFuture&#39; = lambda_interp&#39;(bNext);
<span class="linenos"> 81</span>  
<span class="linenos"> 82</span>  <span class="c">% Calculate Euler residuals</span>
<span class="linenos"> 83</span>  c = (omega*cT^(-eta) + (1-omega)*cN^(-eta))^(-1/eta);
<span class="linenos"> 84</span>  partial_c_partial_cT = (omega*cT^(-eta) + (1-omega)*cN^(-eta))^(-1/eta-1) * omega * cT^(-eta-1);
<span class="linenos"> 85</span>  lambda = c^(-sigma)*partial_c_partial_cT;
<span class="linenos"> 86</span>  euler_residual = 1 - beta*(1+r) * <span class="k">GDSGE_EXPECT</span>{lambdaFuture&#39;}/lambda - mu;
<span class="linenos"> 87</span>  
<span class="linenos"> 88</span>  <span class="c">% Price consistent</span>
<span class="linenos"> 89</span>  price_consistency = pN - ((1-omega)/omega)*(cT/cN)^(eta+1);
<span class="linenos"> 90</span>  
<span class="linenos"> 91</span>  <span class="c">% budget constraint</span>
<span class="linenos"> 92</span>  budget_residual = b*(1+r)+yT+pN*yN - (bNext+cT+pN*cN);
<span class="linenos"> 93</span>  
<span class="linenos"> 94</span>  <span class="k">equations;</span>
<span class="linenos"> 95</span>    euler_residual;
<span class="linenos"> 96</span>    mu*nbNext;
<span class="linenos"> 97</span>    price_consistency;
<span class="linenos"> 98</span>    budget_residual;
<span class="linenos"> 99</span>  <span class="k">end;</span>
<span class="linenos">100</span><span class="k">end;</span>
<span class="linenos">101</span>
<span class="linenos">102</span><span class="k">simulate;</span>
<span class="linenos">103</span>  <span class="k">num_periods</span> = 1000;
<span class="linenos">104</span>  <span class="k">num_samples</span> = 100;
<span class="linenos">105</span>  <span class="k">initial</span> b 0.0
<span class="linenos">106</span>  <span class="k">initial</span> shock 1;
<span class="linenos">107</span>  <span class="k">var_simu</span> c pN;
<span class="linenos">108</span>  b&#39; = bNext;
<span class="linenos">109</span><span class="k">end;</span>
</pre></div>
</div>
<p>Here are some comments on the implementation.</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">2</span>USE_ASG=1; USE_SPLINE=0;
<span class="linenos">3</span>AsgMaxLevel = 10;
<span class="linenos">4</span>AsgThreshold = 1e-4;
</pre></div>
</div>
<p>These lines specify the option that the adaptive sparse grid (ASG) method uses for function approximations.
The ASG method is based on <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S002199910900028X">Ma and Zabaras (2009)</a>,
brought to economics by <a class="reference external" href="https://onlinelibrary.wiley.com/doi/abs/10.3982/ECTA12216">Brumm and Scheidegger (2017)</a>
and features sparsity for multi-dimensional problems and thus can accommodate models with high-dimension state space.
In the current context with one dimension continuous state space, the method works to automatically refine the discretized grid
in the region of state space featuring high nonlinearity.
The method uses hat functions as the basis functions defined in a hierarchy structure. Option <em>AsgMaxLevel</em> specifies the
the maximum level at which the refinement stops, and option <em>AsgThreshold</em> specifies the threshold below which the refinement stops.
See more options for the adaptive sparse grid in <a class="reference internal" href="../../usage/functions.html#toolbox-api"><span class="std std-ref">Toolbox API</span></a>.</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="c">% Define the last-period problem</span>
<span class="linenos">42</span><span class="k">var_policy</span>_init dummy;
<span class="linenos">43</span><span class="k">inbound</span>_init dummy -1.0 1.0;
<span class="linenos">44</span>
<span class="linenos">45</span><span class="k">var_aux</span>_init c lambda;
<span class="linenos">46</span><span class="k">model_init;</span>
<span class="linenos">47</span>  cT = yT + b*(1+r);
<span class="linenos">48</span>  cN = yN;
<span class="linenos">49</span>  c = (omega*cT^(-eta) + (1-omega)*cN^(-eta))^(-1/eta);
<span class="linenos">50</span>  partial_c_partial_cT = (omega*cT^(-eta) + (1-omega)*cN^(-eta))^(-1/eta-1) * omega * cT^(-eta-1);
<span class="linenos">51</span>  lambda = c^(-sigma)*partial_c_partial_cT;
<span class="linenos">52</span>  
<span class="linenos">53</span>  <span class="k">equations;</span>
<span class="linenos">54</span>    0;
<span class="linenos">55</span>  <span class="k">end;</span>
<span class="linenos">56</span><span class="k">end;</span>
</pre></div>
</div>
<p>These lines define the starting point of the time iteration, which is based on the solution to a last-period problem. In this model
the last-period problem is actually trivial: it just specifies the marginal utility derived from consuming all endowments (of tradable and non-tradable) and bond holdings.
We do not need to solve a system of equations for this, but we want to organize the calculations in a
readable format. These lines demonstrate how such procedure can be done by defining a trivial <em>model_init;</em> block, which accepts a dummy as unknown,
and returns variables needed in <em>var_aux_init</em>.</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">78</span>  bNext = nbNext - (kappaN*pN*yN + kappaT*yT);
</pre></div>
</div>
<p>This line demonstrates how to transform the borrowing constraint tied to an endogenous asset price <span class="math notranslate nohighlight">\(b_{t+1} \geq - (\kappa^N p_t^N y_t^N + \kappa^T y_t^T)\)</span>, into a boxed constraint.
This is done by defining <span class="math notranslate nohighlight">\(nb_{t+1}=b_{t+1} + (\kappa^N p_t^N y_t^N + \kappa^T y_t^T)\)</span>, and specifying a non-negative constraint for unknown <span class="math notranslate nohighlight">\(nb_{t+1}\)</span>.
In the evaluations of the equations, we transform <span class="math notranslate nohighlight">\(nb_{t+1}\)</span> back to <span class="math notranslate nohighlight">\(b_{t+1}\)</span> with the line defined above.</p>
</section>
<section id="results">
<h2>Results<a class="headerlink" href="#results" title="Permalink to this heading"></a></h2>
<p>Upload and compile the gmod file through the <a class="reference external" href="http://www.gdsge.com">online compiler</a>. We first run policy iterations in a narrower state space, then expand it to cover the ergodic set</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt;&gt; options = struct;
shock_process = load(&#39;shock_process.mat&#39;);
options.shock_trans = shock_process.shock_trans;
options.yT = shock_process.yT;
options.yN = shock_process.yN;
options.MaxIter = 50;
IterRslt = iter_bianchi2011(options);

options.MaxIter = inf;
options.WarmUp = IterRslt;
options.SkipModelInit = 1;
options.bMin = -1.1;
options.bMax = 0.0;
options.b = [options.bMin,options.bMax];
IterRslt = iter_bianchi2011(options);
</pre></div>
</div>
<p>As shown above, the options specified in a structure can be passed into the <em>iter</em> file to overwrite existing parameters. (All parameters
with names CapitalUpperCaseOption can be overwritten without recompiling). We first load the exact discretized processes
used in <a class="reference external" href="https://www.aeaweb.org/articles?id=10.1257/aer.101.7.3400">Bianchi (2011)</a>. Make sure you have file
<a class="reference download internal" download="" href="../../_downloads/e6cdc44210ba8a916c67ec73a2b38c1d/shock_process.mat"><code class="xref download docutils literal notranslate"><span class="pre">shock_process.mat</span></code></a> ready.
<em>MaxIter</em> defines the maximum number of policy iterations before which
the procedure stops. Since we are just warming up on a coarse state space, let’s set it 50. The returned IterRslt is then passed to the <em>iter</em> file again
in a structure, in the field named <em>WarmUp</em>. This basically overwrites the starting point of the policy iteration with the solution obtained
in the previous <em>iter</em> call. Accordingly, option <em>SkipModelInit</em> is set to one to skip the <em>model_init;</em> block as it is not used (this step is optional but can be helpful in cases
where the last-period problem takes time to solve and is not guaranteed to find solutions in the expanded state space).</p>
<p>Finally, we overwrite the state space to enlarge the interval for <em>b</em> to <span class="math notranslate nohighlight">\([-1.1,0.0]\)</span> which ensures that it covers the ergodic set. This procedure should be done recursively:
expanding the state space until it covers the ergodic set found in the simulations.</p>
<p>MATLAB displays:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Iter:10, Metric:0.0102642, maxF:8.66941e-09
Elapsed time is 0.462853 seconds.

...

Iter:77, Metric:4.31948e-07, maxF:9.36793e-09
Elapsed time is 1.616132 seconds.
</pre></div>
</div>
<p>We can now inspect the policy functions using following MATLAB commands:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt;&gt; asg_output = asg.construct_from_struct(IterRslt.asg_output_struct);
grids = asg_output.get_grids_info;
idx_bNext = 1;
idx_pN = 2;
for j=1:16
    grid = grids{j};
    lenGrid = length(grid);
    bNext_fval{j} = asg_output.eval(j*ones(1,lenGrid),idx_bNext*ones(1,lenGrid),grid);
    pN_fval{j} = asg_output.eval(j*ones(1,lenGrid),idx_pN*ones(1,lenGrid),grid);
end

figure;
subplot(2,1,1); hold on;
xy = sortrows([grids{1}&#39;,bNext_fval{1}&#39;]);
plot(xy(:,1),xy(:,2),&#39;ro-&#39;);
xy = sortrows([grids{4}&#39;,bNext_fval{4}&#39;]);
plot(xy(:,1),xy(:,2),&#39;kx-&#39;);
title(&#39;Policy functions for next period bond holding, $b&#39;&#39;$&#39;,&#39;interpreter&#39;,&#39;latex&#39;,&#39;FontSize&#39;,12);
xlabel(&#39;Current bond holding, $b$&#39;,&#39;FontSize&#39;,12,&#39;interpreter&#39;,&#39;latex&#39;);

subplot(2,1,2); hold on;
xy = sortrows([grids{1}&#39;,pN_fval{1}&#39;]);
plot(xy(:,1),xy(:,2),&#39;ro-&#39;);
xy = sortrows([grids{4}&#39;,pN_fval{4}&#39;]);
plot(xy(:,1),xy(:,2),&#39;kx-&#39;);
title(&#39;Policy functions for non-tradable goods price, $p^N$&#39;,&#39;interpreter&#39;,&#39;latex&#39;,&#39;FontSize&#39;,12);
xlabel(&#39;Current bond holding, $b$&#39;,&#39;FontSize&#39;,12,&#39;interpreter&#39;,&#39;latex&#39;);
legend({&#39;$y_t^T$ Lowest, $y_t^N$ Lowest&#39;,&#39;$y_t^T$ Highest, $y_t^N$ Lowest&#39;},&#39;Location&#39;,&#39;SouthEast&#39;,&#39;interpreter&#39;,&#39;latex&#39;,&#39;FontSize&#39;,12);
print(&#39;figures/policy_combined.png&#39;,&#39;-dpng&#39;);
</pre></div>
</div>
<p>This is a bit involved than previous examples since the ASG method returns solutions in a structure
that allows solutions for each exogenous shock to be defined over different grids. So the above procedure essentially unpacks the
grid and reconstructs the values of the policy functions (using asg_output.eval, where asg_output is the adaptive sparse grid approximation object
constructed from the converged solution.
The second argument in asg_output.eval (<em>idx_bNext</em> and <em>idx_pN</em> here) refers to the index of policy functions according the order declared in <em>var_output</em>).
These codes generate the following figure:</p>
<a class="reference internal image-reference" href="../../_images/policy_combined.png"><img alt="../../_images/policy_combined.png" src="../../_images/policy_combined.png" style="width: 700.0px; height: 524.8000000000001px;" /></a>
<p>As shown in the figure, the policy functions are highly nonlinear: when the borrowing constraint binds,
the price of non-tradable goods declines sharply in the level of exist borrowing; future borrowing declines,
instead of increasing, as the economy goes further in debt, implying current account reversals.
If the borrowing constraint does not bind, then the price movement is much milder as we vary the level of existing debt,
and current account reversals do not happen.</p>
<p>The markers on the policy functions indicate the grid points automatically placed by the adaptive-grid method,
and show that the method adds more points to the state space where the policy and state transition functions become non-linear.
Importantly, the method takes care that these non-linear regions can differ across exogenous states, as shown in the figure.
This illustrates the effectiveness of the adaptive-grid method for this class of models,
as these non-linear regions of state-space cannot be determined ex-ante, and require very dense exogenous grids  or painful manual configurations.</p>
<p>We can also inspect the ergodic distribution of the endogenous state variable, bond holding, by calling in MATLAB</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SimuRslt = simulate_bianchi2011(IterRslt);

figure; hold on;
histogram(SimuRslt.b(:,500:end),50,&#39;Normalization&#39;,&#39;pdf&#39;);
[density,grid] = ksdensity(reshape(SimuRslt.b(:,500:end),1,[]));
plot(grid,density,&#39;r-&#39;,&#39;LineWidth&#39;,2);
title(&#39;Histogram and Kernel Density of Bond Holdings&#39;,&#39;interpreter&#39;,&#39;latex&#39;,&#39;FontSize&#39;,12);
xlabel(&#39;Bond holdings, $b$&#39;,&#39;FontSize&#39;,12,&#39;interpreter&#39;,&#39;latex&#39;);
ylabel(&#39;Probability density&#39;,&#39;interpreter&#39;,&#39;latex&#39;);
print(&#39;figures/histogram_b.png&#39;,&#39;-dpng&#39;);
</pre></div>
</div>
<p>which produces</p>
<a class="reference internal image-reference" href="../../_images/histogram_b.png"><img alt="../../_images/histogram_b.png" src="../../_images/histogram_b.png" style="width: 437.5px; height: 328.0px;" /></a>
<p>This shows that the non-linear regions do exist in the ergodic set of the equilibrium and thus cannot be ignored,
but due to precautionary motives, the frequency of the economy being in these regions cannot be determined ex-ante, highlighting the necessity of using a global solution method.</p>
<p>A final remark to be made here is that the toolbox by default resolves the equilibrium system at each time step of the simulation, minimizing
the numerical error within a period. Alternatively, one can add the following line in the gmod file (recompilation needed) to switch to interpolating policy and state transition functions in the simulation.</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>SIMU_RESOLVE=0; SIMU_INTERP=1;
</pre></div>
</div>
<p>Directly interpolating the policy and state transition functions results in much faster speed for simulation. We plot the ergodic distribution obtained from the direct interpolation method below</p>
<a class="reference internal image-reference" href="../../_images/histogram_b_interp.png"><img alt="../../_images/histogram_b_interp.png" src="../../_images/histogram_b_interp.png" style="width: 437.5px; height: 328.0px;" /></a>
<p>As shown in the figure, for the current one-dimension model solved with the adaptive-grid method, the differences in simulations generated by the two methods are not visually distinguishable, highlighting the accuracy of the approximation method.</p>
</section>
<section id="the-planner-s-solution">
<h2>The Planner’s solution<a class="headerlink" href="#the-planner-s-solution" title="Permalink to this heading"></a></h2>
<p>The planner’s solution takes care of the effect of tradable/non-tradable consumption on the relative price.
The planner’s solution differs from the competitive equilibrium by replacing the first order condition from</p>
<div class="math notranslate nohighlight">
\[\lambda_t=u'(c_{t}) \frac{\partial c_t}{\partial c_t^T}\]</div>
<p>to</p>
<div class="math notranslate nohighlight">
\[\lambda_t=u'(c_{t}) \frac{\partial c_t}{\partial c_t^T} +
\mu_t \underbrace{ \kappa^N\Big(\frac{1-\omega}{\omega}\Big)  (\eta+1) [c_t^T]^{\eta} [y_t^N]^{-\eta}}_{\Psi_t}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\Psi_t=\kappa^N (p_t^Nc_t^N)/(c_t^T)(1+\eta)\]</div>
<p>The planner’s problem can thus implemented by replacing Line 85</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">85</span>  lambda = c^(-sigma)*partial_c_partial_cT;
</pre></div>
</div>
<p>to the following (see full gmod file for the planner’s problem <a class="reference download internal" download="" href="../../_downloads/3e20f51a8d88c110313ce57fe2e031d3/bianchi2011_planner.gmod"><code class="xref download docutils literal notranslate"><span class="pre">bianchi2011_planner.gmod</span></code></a>)</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>Psi = kappaN*pN*cN / cT * (1+eta);
lambda = c^(-sigma)*partial_c_partial_cT / (1-mu*Psi);
</pre></div>
</div>
<p>As highlighted in <a class="reference external" href="https://www.aeaweb.org/articles?id=10.1257/aer.101.7.3400">Bianchi (2011)</a>,
since the planner takes into account the effect of cutting down tradable consumption on relative price and the borrowing constraint,
it chooses to accumulate less debt compared to the competitive equilibrium. This can be seen below by comparing the policy functions for
next-period bond and the ergodic distributions of bond holdings for the two economies.</p>
<a class="reference internal image-reference" href="../../_images/compare_b_policy.png"><img alt="../../_images/compare_b_policy.png" src="../../_images/compare_b_policy.png" style="width: 437.5px; height: 328.0px;" /></a>
<a class="reference internal image-reference" href="../../_images/compare_histogram_b.png"><img alt="../../_images/compare_histogram_b.png" src="../../_images/compare_histogram_b.png" style="width: 437.5px; height: 328.0px;" /></a>
</section>
<section id="what-s-next">
<h2>What’s Next?<a class="headerlink" href="#what-s-next" title="Permalink to this heading"></a></h2>
<p>This example illustrates the power of the adaptive grid method to deal with non-linear models. Since the method is designed based on sparse grid,
it solves effectively non-linear models with high-dimensional state space. See example <a class="reference external" href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3552189">Cao, Evans, and Luo (2020)</a> for a two-country Real Business Cycle model on the medium-run
dynamics of exchange rate, in a model featuring portfolio choice, incomplete markets, and occasionally binding constraints, in which the dimension of the endogenous state space
goes up to five.</p>
<p>Or you can directly proceed to <a class="reference internal" href="../../usage/functions.html#toolbox-api"><span class="std std-ref">Toolbox API</span></a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../Guvenen2009/Guvenen2009.html" class="btn btn-neutral float-left" title="Guvenen (2009): Asset Pricing with Heterogeneous IES" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../safe_assets/safe_assets.html" class="btn btn-neutral float-right" title="Barro et al. (2017): Safe Assets with Rare Disasters" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Dan Cao, Wenlan Luo, and Guangyu Nie.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>