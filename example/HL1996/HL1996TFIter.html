<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Heaton and Lucas (1996): Transition Function Iteration &mdash; GDSGE Homepage</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Kiyotaki and Moore (1997): Credit Cycles" href="../KM1997/KM1997.html" />
    <link rel="prev" title="Coleman (1991): A production economy with an income tax" href="../Coleman1991/Coleman1991.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> GDSGE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lectures.html">Lectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbc.html">Getting Started - A Simple RBC Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simple_zlb/simple_zlb.html">Comparison with OccBin: A Simple Model with an Occasionally Binding Interest Rate ZLB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbcIrr.html">An RBC Model with Irreversible Investment</a></li>
<li class="toctree-l1"><a class="reference internal" href="HL1996.html">Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Guvenen2009/Guvenen2009.html">Guvenen (2009): Asset Pricing with Heterogeneous IES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bianchi2011/Bianchi2011.html">Bianchi (2011): Sudden Stops in Open Economies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../safe_assets/safe_assets.html">Barro et al. (2017): Safe Assets with Rare Disasters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandemic/GLSW2020.html">Guerrieri et al. (2020): Negative Supply Shocks That Cause Demand Shortages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../multi_country_rbc/multi_country_rbc.html">A Multi-country Business Cycle Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ZLB/zlb.html">A New-Keynesian Model with an Occasionally Binding Interest Rate Zero Lower Bound</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage/functions.html">Toolbox API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdditionalExamples.html">Additional Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../ContributedExamples.html">Contributed Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Coleman1991/Coleman1991.html">Coleman (1991): A production economy with an income tax</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Heaton and Lucas (1996): Transition Function Iteration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-gmod-file">The gmod File</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../KM1997/KM1997.html">Kiyotaki and Moore (1997): Credit Cycles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Brumm2015/Brumm2015.html">Brumm et al (2015): A GDSGE model with asset price bubble</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GDSGE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../ContributedExamples.html">Contributed Examples</a> &raquo;</li>
      <li>Heaton and Lucas (1996): Transition Function Iteration</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="heaton-and-lucas-1996-transition-function-iteration">
<h1>Heaton and Lucas (1996): Transition Function Iteration<a class="headerlink" href="#heaton-and-lucas-1996-transition-function-iteration" title="Permalink to this heading"></a></h1>
<p>In the <a class="reference internal" href="HL1996.html#heaton-and-lucas-1996-incomplete-markets-with-portfolio-choices"><span class="std std-ref">Heaton and Lucas (1996)</span></a> example,
one of the challenges in solving the model
is the fact that the endogenous state variable, agents 1’s wealth share (or consumption share), has an implicit law of motion.
We tackle this issue by including future values of the state variables among the unknown policy variables
to solve for in each iteration. We also include the <em>consistency equations</em> in the system of equilibrium conditions.
These equations require that future realizations of wealth share are consistent with current portfolio choices
and future realizations of stock price, dividend, and aggregate growth rate:</p>
<div class="math notranslate nohighlight">
\[\omega_{t+1}^{1}=\frac{(\hat{p}_{t+1}^{s}+\hat{d}_{t+1})s_{t+1}^{1}+\frac{\hat{b}_{t+1}^{1}}{\gamma^a_{t+1}}}{\hat{p}_{t+1}^{s}+\hat{d}_{t+1}}.\]</div>
<p>An alternative approach to the implicit law of motion is, in each policy function iteration, to start from a conjectured transition function
for the endogenous state variable and use it to forecast future policy variables (consumption, stock price, etc.).
These forecasts can then be used to solve for current policy variables using the same system of equilibrium conditions (excluding the consistency equations).
At the end of each iteration, the conjectured transition function is updated using the solution of the current policy variables.
In a way, the approach iterates over both policy and transition functions.
Therefore, to differentiate from the standard policy function iteration, we call this method <em>transition function iteration</em>.</p>
<p>There are two advantages of this alternative approach compared to our main policy function iteration approach
with consistency equations.
First, there are a fewer equations to be solved in each iteration.
Second, the forecasts for future policy variables can be computed at the beginning of each iteration,
independent of equation solving during the iteration.
A potential drawback is that the solution might not be as accurate as the original method because the consistency equations
might not be satisfied with high precision. However, one might start with this alternative to obtain
solution with reasonable accuracy quickly then switch back to the our main approach to achieve higher accuracy.</p>
<p>The alternative approach is developed by
<a class="reference external" href="https://www.vadimelenev.com">Vadim Elenev</a> (Johns Hopkins University),
<a class="reference external" href="https://sites.google.com/view/timlandvoigt">Tim Landvoigt</a> (University Pennsylvania),
and <a class="reference external" href="https://www0.gsb.columbia.edu/faculty/svannieuwerburgh">Stijn Van Nieuwerburgh</a> (Columbia University),
to solve <a class="reference external" href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2748230">their model with rich empirical content</a>,
featuring both financial and non-financial sectors and a government. (The endogenous state variables with implicit laws of motion include aggregate producers’ leverage and aggregate banks’ net-worth.)
The model captures salient features of macro-finance dynamics during the Great Recession and
has important implications on bank capital regulation.</p>
<p>The authors showed us that this approach can also be used to solve the model in <a class="reference external" href="https://www.journals.uchicago.edu/doi/10.1086/262030">Heaton and Lucas (1996)</a>
with reasonable accuracy and have kindly contributed this example to this website. Our GDSGE toolbox can implement this approach and its gmod file for
<a class="reference external" href="https://www.journals.uchicago.edu/doi/10.1086/262030">Heaton and Lucas (1996)</a>’s model is given below.
We design two features of the toolbox, macros for loop and <em>pre-model</em> block, to
faciliate the implementation of the approach and to make the most of its computation economizing property.
We discuss these features in more detail below.</p>
<p>Notice that this approach requires some dampening in the update of policy and transition functions:</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">57</span>damp = 0.25;
<span class="linenos">58</span>ps_future = ps_future*damp + (1-damp)*ps;
<span class="linenos">59</span>c1_future = c1_future*damp + (1-damp)*c1;
<span class="linenos">60</span>c2_future = c2_future*damp + (1-damp)*c2;
<span class="linenos">61</span>index_current = @(vec,current_idx) squeeze(vec(:,current_idx,:));
<span class="linenos">62</span>#for i=1:N
<span class="linenos">63</span>  w1_future_#i = w1_future_#i*damp + (1-damp)*index_current(reshape(w1n,[<span class="k">shock_num</span> GDSGE_SIZE]),#i);
<span class="linenos">64</span>#end
</pre></div>
</div>
<p>As also noted above, over the iterations, the consistency equations are not required to be satisfied
so they are excluded from the system of equilibrium conditions in the gmod file:</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 99</span>  <span class="k">equations;</span>
<span class="linenos">100</span>    -1+beta*es1+ms1;
<span class="linenos">101</span>    -1+beta*es2+ms2;
<span class="linenos">102</span>    -1+beta*eb1+mb1;
<span class="linenos">103</span>    -1+beta*eb2+mb2;
<span class="linenos">104</span>    ms1*s1p;
<span class="linenos">105</span>    ms2*s2p;
<span class="linenos">106</span>    mb1*nb1p;
<span class="linenos">107</span>    mb2*nb2p;
<span class="linenos">108</span>    b1p+b2p;
<span class="linenos">109</span>    budget_1 / w1;
<span class="linenos">110</span>    budget_2 / (1-w1);
<span class="linenos">111</span>  <span class="k">end;</span>
</pre></div>
</div>
<p>Therefore, once the algorithm converges for policy functions,
one can switch back to the original gmod file in
<a class="reference internal" href="HL1996.html#heaton-and-lucas-1996-incomplete-markets-with-portfolio-choices"><span class="std std-ref">Heaton and Lucas (1996)</span></a> with
the consistency equations in order to make sure that these equations are satisfied with higher precision.
However, the new converged solution would not differ significantly from the old one.</p>
<section id="the-gmod-file">
<h2>The gmod File<a class="headerlink" href="#the-gmod-file" title="Permalink to this heading"></a></h2>
<p><a class="reference download internal" download="" href="../../_downloads/190db13bb08dc1b534af7c147e992950/HL1996TFIter.gmod"><code class="xref download docutils literal notranslate"><span class="pre">HL1996TFIter.gmod</span></code></a></p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span>#define N 8;
<span class="linenos">  2</span>SaveFreq = inf;
<span class="linenos">  3</span><span class="c">% Parameters</span>
<span class="linenos">  4</span><span class="k">parameters</span> beta gamma Kb;
<span class="linenos">  5</span>beta = 0.95;  <span class="c">% discount factor</span>
<span class="linenos">  6</span>gamma = 1.5;  <span class="c">% CRRA coefficient</span>
<span class="linenos">  7</span>Kb = -0.05;   <span class="c">% borrowing limit in ratio of aggregate output</span>
<span class="linenos">  8</span><span class="c">% Exogenous state variables</span>
<span class="linenos">  9</span><span class="k">var_shock</span> g d eta1;
<span class="linenos"> 10</span><span class="c">% Enumerate exogenous states and transition matrix</span>
<span class="linenos"> 11</span><span class="k">shock_num</span> = N;
<span class="linenos"> 12</span>g = [.9904 1.0470 .9904 1.0470 .9904 1.0470 .9904 1.0470];
<span class="linenos"> 13</span>d = [.1402 .1437 .1561 .1599 .1402 .1437 .1561 .1599];
<span class="linenos"> 14</span>eta1 = [.3772 .3772 .3772 .3772 .6228 .6228 .6228 .6228];
<span class="linenos"> 15</span><span class="k">shock_trans</span> = [
<span class="linenos"> 16</span>    0.3932 0.2245 0.0793 0.0453 0.1365 0.0779 0.0275 0.0158
<span class="linenos"> 17</span>    0.3044 0.3470 0.0425 0.0484 0.1057 0.1205 0.0147 0.0168
<span class="linenos"> 18</span>    0.0484 0.0425 0.3470 0.3044 0.0168 0.0147 0.1205 0.1057
<span class="linenos"> 19</span>    0.0453 0.0793 0.2245 0.3932 0.0157 0.0275 0.0779 0.1366
<span class="linenos"> 20</span>    0.1366 0.0779 0.0275 0.0157 0.3932 0.2245 0.0793 0.0453
<span class="linenos"> 21</span>    0.1057 0.1205 0.0147 0.0168 0.3044 0.3470 0.0425 0.0484
<span class="linenos"> 22</span>    0.0168 0.0147 0.1205 0.1057 0.0484 0.0425 0.3470 0.3044
<span class="linenos"> 23</span>    0.0158 0.0275 0.0779 0.1365 0.0453 0.0793 0.2245 0.3932
<span class="linenos"> 24</span>    ];
<span class="linenos"> 25</span><span class="c">% Endogenous state variables</span>
<span class="linenos"> 26</span><span class="k">var_state</span> w1;  % wealth share
<span class="linenos"> 27</span>w1 = linspace(-0.04,1.04,201);
<span class="linenos"> 28</span><span class="c">% Policy variables and bounds that enter the equations</span>
<span class="linenos"> 29</span><span class="k">var_policy</span> c1 c2 s1p nb1p nb2p ms1 ms2 mb1 mb2 ps pb;
<span class="linenos"> 30</span><span class="k">inbound</span> c1 0.1 1;
<span class="linenos"> 31</span><span class="k">inbound</span> c2 0.1 1;
<span class="linenos"> 32</span><span class="k">inbound</span> s1p 0.0 1.0;
<span class="linenos"> 33</span><span class="k">inbound</span> nb1p 0.0 1.0;   % nb1p=b1p-Kb
<span class="linenos"> 34</span><span class="k">inbound</span> nb2p 0.0 1.0;   
<span class="linenos"> 35</span><span class="k">inbound</span> ms1 0 1;        % Multipliers for constraints
<span class="linenos"> 36</span><span class="k">inbound</span> ms2 0 1;
<span class="linenos"> 37</span><span class="k">inbound</span> mb1 0 1;
<span class="linenos"> 38</span><span class="k">inbound</span> mb2 0 1;
<span class="linenos"> 39</span>inbound ps 0 10 <span class="k">adaptive</span>(1.5);
<span class="linenos"> 40</span>inbound pb 0 10 <span class="k">adaptive</span>(1.5);
<span class="linenos"> 41</span><span class="c">% Other policy variables</span>
<span class="linenos"> 42</span><span class="k">var_aux</span> equity_premium w1n[N];
<span class="linenos"> 43</span><span class="c">% Interpolation variables for policy and state transitions</span>
<span class="linenos"> 44</span><span class="k">var_interp</span> ps_future c1_future c2_future;
<span class="linenos"> 45</span>ergodic = <span class="k">shock_trans</span>^50;
<span class="linenos"> 46</span>ergodic = ergodic(1,:);
<span class="linenos"> 47</span>deltabar = ergodic * d&#39;;
<span class="linenos"> 48</span>etabar = ergodic * eta1&#39;;
<span class="linenos"> 49</span>gammabar = ergodic * g&#39;;
<span class="linenos"> 50</span><span class="k">initial</span> ps_future beta*deltabar*gammabar^(1-gamma)/(1-beta*gammabar^(1-gamma));;
<span class="linenos"> 51</span><span class="k">initial</span> c1_future (1-deltabar)*etabar+0.5*deltabar;
<span class="linenos"> 52</span><span class="k">initial</span> c2_future (1-deltabar)*(1-etabar)+0.5*deltabar;
<span class="linenos"> 53</span>#for i=1:N
<span class="linenos"> 54</span>  <span class="k">var_interp</span> w1_future_#i;
<span class="linenos"> 55</span>  <span class="k">initial</span> w1_future_#i 0.5; % A place holder
<span class="linenos"> 56</span>#end
<span class="linenos"> 57</span>damp = 0.25;
<span class="linenos"> 58</span>ps_future = ps_future*damp + (1-damp)*ps;
<span class="linenos"> 59</span>c1_future = c1_future*damp + (1-damp)*c1;
<span class="linenos"> 60</span>c2_future = c2_future*damp + (1-damp)*c2;
<span class="linenos"> 61</span>index_current = @(vec,current_idx) squeeze(vec(:,current_idx,:));
<span class="linenos"> 62</span>#for i=1:N
<span class="linenos"> 63</span>  w1_future_#i = w1_future_#i*damp + (1-damp)*index_current(reshape(w1n,[<span class="k">shock_num</span> GDSGE_SIZE]),#i);
<span class="linenos"> 64</span>#end
<span class="linenos"> 65</span>
<span class="linenos"> 66</span>pre_<span class="k">model;</span>
<span class="linenos"> 67</span>  <span class="c">% Evaluate interpolation</span>
<span class="linenos"> 68</span>  w1n_fixed&#39; = 0;
<span class="linenos"> 69</span>  #for i=1:N
<span class="linenos"> 70</span>    if shock==#i
<span class="linenos"> 71</span>      w1n_fixed&#39; = w1_future_#i&#39;(w1);
<span class="linenos"> 72</span>    end
<span class="linenos"> 73</span>  #end
<span class="linenos"> 74</span>  [psn&#39;,c1n&#39;,c2n&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>[1:3](w1n_fixed&#39;);
<span class="linenos"> 75</span>  es1_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c1n&#39;)^(-gamma)*(psn&#39;+d&#39;)};
<span class="linenos"> 76</span>  es2_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c2n&#39;)^(-gamma)*(psn&#39;+d&#39;)};
<span class="linenos"> 77</span>  eb1_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c1n&#39;)^(-gamma)};
<span class="linenos"> 78</span>  eb2_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c2n&#39;)^(-gamma)};
<span class="linenos"> 79</span><span class="k">end;</span>
<span class="linenos"> 80</span>
<span class="linenos"> 81</span><span class="k">model;</span>
<span class="linenos"> 82</span>  <span class="c">% Calculate expectations that enter the Euler Equations</span>
<span class="linenos"> 83</span>  es1 = es1_future*c1^gamma/ps;
<span class="linenos"> 84</span>  es2 = es2_future*c2^gamma/ps;
<span class="linenos"> 85</span>  eb1 = eb1_future*c1^gamma/pb;
<span class="linenos"> 86</span>  eb2 = eb2_future*c2^gamma/pb;
<span class="linenos"> 87</span>  <span class="c">% Transform bond back</span>
<span class="linenos"> 88</span>  b1p = nb1p + Kb;
<span class="linenos"> 89</span>  b2p = nb2p + Kb;
<span class="linenos"> 90</span>  <span class="c">% Market clearing of shares</span>
<span class="linenos"> 91</span>  s2p = 1-s1p;
<span class="linenos"> 92</span>  <span class="c">% Budget constraints</span>
<span class="linenos"> 93</span>  budget_1 = w1*(ps+d)+eta1 - c1 - ps*s1p - pb*b1p;
<span class="linenos"> 94</span>  budget_2 = (1-w1)*(ps+d)+(1-eta1) - c2 - ps*s2p - pb*b2p;
<span class="linenos"> 95</span>  <span class="c">% Consistency equations</span>
<span class="linenos"> 96</span>  w1n&#39; = (s1p*(psn&#39;+d&#39;) + b1p/g&#39;)/(psn&#39;+d&#39;);
<span class="linenos"> 97</span>  <span class="c">% Other policy variables</span>
<span class="linenos"> 98</span>  equity_premium = <span class="k">GDSGE_EXPECT</span>{(psn&#39;+d&#39;)/ps*g&#39;} - 1/pb;
<span class="linenos"> 99</span>  <span class="k">equations;</span>
<span class="linenos">100</span>    -1+beta*es1+ms1;
<span class="linenos">101</span>    -1+beta*es2+ms2;
<span class="linenos">102</span>    -1+beta*eb1+mb1;
<span class="linenos">103</span>    -1+beta*eb2+mb2;
<span class="linenos">104</span>    ms1*s1p;
<span class="linenos">105</span>    ms2*s2p;
<span class="linenos">106</span>    mb1*nb1p;
<span class="linenos">107</span>    mb2*nb2p;
<span class="linenos">108</span>    b1p+b2p;
<span class="linenos">109</span>    budget_1 / w1;
<span class="linenos">110</span>    budget_2 / (1-w1);
<span class="linenos">111</span>  <span class="k">end;</span>
<span class="linenos">112</span><span class="k">end;</span>
<span class="linenos">113</span>
<span class="linenos">114</span><span class="k">simulate;</span>
<span class="linenos">115</span>  <span class="k">num_periods</span> = 10000;
<span class="linenos">116</span>  <span class="k">num_samples</span> = 24;
<span class="linenos">117</span>  <span class="k">initial</span> w1 0.5;
<span class="linenos">118</span>  <span class="k">initial</span> shock 1;
<span class="linenos">119</span>  <span class="k">var_simu</span> c1 c2 ps pb equity_premium ms1 mb1;
<span class="linenos">120</span>  w1&#39; = w1n&#39;;
<span class="linenos">121</span><span class="k">end;</span>
</pre></div>
</div>
<p>Notice that, to implement this alternative algorithm, the gmod code uses two features of the toolbox on top of the original example with consistency equations.
First, since this alternative algorithm needs to evaluate the state transition function for the current state
to get the future endogenous state variables that corresponds to each of the future realizations, one needs to include the state transition function
<em>for each of the current state</em> as <em>var_interp</em>. For the current example, this means 8 state transition functions corresponding to each of the current state.
Accordingly, these state transition functions need to be initialized, updated, and evaluated in the model block. This can be done compactly by using a macro for loop
in the gmod file, replicated below</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">53</span>#for i=1:N
<span class="linenos">54</span>  <span class="k">var_interp</span> w1_future_#i;
<span class="linenos">55</span>  <span class="k">initial</span> w1_future_#i 0.5; % A place holder
<span class="linenos">56</span>#end
</pre></div>
</div>
<p>This block expands to</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="k">var_interp</span> w1_future_1;
<span class="k">initial</span> w1_future_1 0.5; % A place holder

<span class="k">var_interp</span> w1_future_2;
<span class="k">initial</span> w1_future_2 0.5; % A place holder

...

<span class="k">var_interp</span> w1_future_8;
<span class="k">initial</span> w1_future_8 0.5; % A place holder
</pre></div>
</div>
<p>In particular, the #for … #end block will repeat the code in the block, and replace the iterator with each value in the value list in the header line starting with #for. And the above code block thus declares
w1_future_1 to w1_future_8 as <em>var_interp</em> and initialize their values. Correspondingly, the following block specifies the updates for each of these state transition functions
after a time step of the policy iteration</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">61</span>index_current = @(vec,current_idx) squeeze(vec(:,current_idx,:));
<span class="linenos">62</span>#for i=1:N
<span class="linenos">63</span>  w1_future_#i = w1_future_#i*damp + (1-damp)*index_current(reshape(w1n,[<span class="k">shock_num</span> GDSGE_SIZE]),#i);
<span class="linenos">64</span>#end
</pre></div>
</div>
<p>in which <em>index_current</em> is a helper function to look up the corresponding current shock index from the returned <em>var_aux</em> w1n after each iteration. Therefore, <em>w1_future_1</em> indeed corresponds to
the state transition function for the current exogenous state indexed by 1, and so on.</p>
<p>The other feature that maximizes the efficiency of the algorithm is by noticing that the future endogenous states are directly evaluated with the state transition function from the last iteration.
Then the future endogenous states are used to evaluate necessary future variables using the policy function from the last iteration.
Therefore, given current
endogenous states and exogenous states, the future endogenous states and future variables do not depend on current policy variables, and thus can be evaluated before solving the equation.
This is enabled by defining the <em>pre_model</em> block in the gmod code, replicated below</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">66</span>pre_<span class="k">model;</span>
<span class="linenos">67</span>  <span class="c">% Evaluate interpolation</span>
<span class="linenos">68</span>  w1n_fixed&#39; = 0;
<span class="linenos">69</span>  #for i=1:N
<span class="linenos">70</span>    if shock==#i
<span class="linenos">71</span>      w1n_fixed&#39; = w1_future_#i&#39;(w1);
<span class="linenos">72</span>    end
<span class="linenos">73</span>  #end
<span class="linenos">74</span>  [psn&#39;,c1n&#39;,c2n&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>[1:3](w1n_fixed&#39;);
<span class="linenos">75</span>  es1_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c1n&#39;)^(-gamma)*(psn&#39;+d&#39;)};
<span class="linenos">76</span>  es2_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c2n&#39;)^(-gamma)*(psn&#39;+d&#39;)};
<span class="linenos">77</span>  eb1_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c1n&#39;)^(-gamma)};
<span class="linenos">78</span>  eb2_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c2n&#39;)^(-gamma)};
<span class="linenos">79</span><span class="k">end;</span>
</pre></div>
</div>
<p>As shown, the <em>pre_model</em> block essentially evaluates the future endogenous states, using the state transition function that corresponds to the index of the current exogenous state,
and then evaluates the future variables that are necessary in evaluating the current equation, by feeding the future endogenous states into the policy functions from the last iteration.
Actually, the <em>pre_model</em> block does a bit more by also calculating the expectations that enter the inter-temporal equations, as they do not depend on current policy variables either.
These expectation terms, combined with current policy variables, arrive at the inter-temporal equations (the Euler equations for bonds and shares) that enter the system, defined in the model block. It should be clear that any variables defined in the <em>pre_model</em> block can be directly used in the <em>model</em> block, and for obvious reasons, the <em>pre_model</em> block can not use any
policy variables declared as <em>var_policy</em>. Evaluating the state transition functions and expectations beforehand has greatly improved the efficiency of this alternative algorithm (for the current example, it reduces the computation time by half), by avoiding redundant evaluations of objects that do not vary with <em>var_policy</em>.</p>
<p>Generally, this alternative algorithm, using the most efficient implementation enabled by procedures above, delivers better performance in computation speed for a time step compared to the algorithm with consistency equations
in <a class="reference internal" href="HL1996.html#heaton-and-lucas-1996-incomplete-markets-with-portfolio-choices"><span class="std std-ref">Heaton and Lucas (1996)</span></a>.
The tradeoff in computation time is that the algorithm with consistency equations solves a larger system of equations
(by including the consistency equations and endogenous states as unknowns)
and does not allow interpolating for future endogenous states and computing expectation beforehand,
but this alternative algorithm constructs more <em>var_interp</em> and needs evaluate interpolation twice
– first to get future endogenous states, then future policy variables.
On the theoretical ground, the algorithm with consistency equations finds solutions as the limit of a finite-horizon economy
and thus can also be used to solve stochastic transition paths.
Besides, it converges more robustly without resorting to ad-hoc dampening.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../Coleman1991/Coleman1991.html" class="btn btn-neutral float-left" title="Coleman (1991): A production economy with an income tax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../KM1997/KM1997.html" class="btn btn-neutral float-right" title="Kiyotaki and Moore (1997): Credit Cycles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Dan Cao, Wenlan Luo, and Guangyu Nie.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>