<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices &mdash; GDSGE Homepage</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Guvenen (2009): Asset Pricing with Heterogeneous IES" href="../Guvenen2009/Guvenen2009.html" />
    <link rel="prev" title="An RBC Model with Irreversible Investment" href="../rbc/rbcIrr.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> GDSGE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lectures.html">Lectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbc.html">Getting Started - A Simple RBC Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../simple_zlb/simple_zlb.html">Comparison with OccBin: A Simple Model with an Occasionally Binding Interest Rate ZLB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rbc/rbcIrr.html">An RBC Model with Irreversible Investment</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-model">The Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wealth-share-as-endogenous-state">Wealth Share as Endogenous State</a></li>
<li class="toctree-l2"><a class="reference internal" href="#evaluate-the-accuracy-of-solutions">Evaluate the Accuracy of Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#consumption-share-as-the-endogenous-state">Consumption Share as the Endogenous State</a></li>
<li class="toctree-l2"><a class="reference internal" href="#comparison-with-alternative-algorithms">Comparison with Alternative Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#toolbox-enabled-by-stpfi">Toolbox enabled by STPFI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#what-s-next">What’s Next?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Guvenen2009/Guvenen2009.html">Guvenen (2009): Asset Pricing with Heterogeneous IES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bianchi2011/Bianchi2011.html">Bianchi (2011): Sudden Stops in Open Economies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../safe_assets/safe_assets.html">Barro et al. (2017): Safe Assets with Rare Disasters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pandemic/GLSW2020.html">Guerrieri et al. (2022): Negative Supply Shocks That Cause Demand Shortages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../multi_country_rbc/multi_country_rbc.html">A Multi-country Business Cycle Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ZLB/zlb.html">A New-Keynesian Model with an Occasionally Binding Interest Rate Zero Lower Bound</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage/functions.html">Toolbox API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdditionalExamples.html">Additional Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ContributedExamples.html">Contributed Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GDSGE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="heaton-and-lucas-1996-incomplete-markets-with-portfolio-choices">
<h1>Heaton and Lucas (1996): Incomplete Markets with Portfolio Choices<a class="headerlink" href="#heaton-and-lucas-1996-incomplete-markets-with-portfolio-choices" title="Permalink to this heading"></a></h1>
<p>The benchmark model in <a class="reference external" href="https://www.journals.uchicago.edu/doi/10.1086/262030">Heaton and Lucas (1996)</a> is a good starting point to
demonstrate the capability of the current framework in dealing with endogenous state variables with implicit law of motions.
The model encompasses many ingredients that appear in recent macroeconomic studies, such as
incomplete markets, portfolio choices, occasionally binding constraint, non-stationary shock process, and asset pricing with non-trivial market-clearing conditions.
We show how the model can be solved with wealth share or consumption share as the endogenous state, which are the two prominent approaches in the literature
and naturally fit in our toolbox framework.</p>
<section id="the-model">
<h2>The Model<a class="headerlink" href="#the-model" title="Permalink to this heading"></a></h2>
<p>This is an incomplete-markets model with two representative agents <span class="math notranslate nohighlight">\(i\in\mathcal{I}=\{1,2\}\)</span> who trade in equity shares and bonds.
The aggregate state <span class="math notranslate nohighlight">\(z\in\boldsymbol{Z}\)</span>, which consists of capital income share, agents’ income share, and aggregate endowment growth,
follows a first-order Markov process. <span class="math notranslate nohighlight">\(p_{t}^{s}(z^t)\)</span> and <span class="math notranslate nohighlight">\(p_{t}^{b}(z^t)\)</span>
denote share price and bond price at time <span class="math notranslate nohighlight">\(t\)</span> and in shock history <span class="math notranslate nohighlight">\(z^t=\{z_0,z_1,\dots,z_t\}\)</span>. To simplify the notations, we omit the explicit dependence on shock history.</p>
<p>Agent <span class="math notranslate nohighlight">\(i\)</span> takes the share and bond prices as given and maximizes her inter-temporal expected utility</p>
<div class="math notranslate nohighlight">
\[\mathcal{U}_{t}^{i}=\mathbb{E}_{t}\left[\sum_{\tau=0}^{\infty}\beta^{\tau}\frac{\left(c_{t+\tau}^{i}\right)^{1-\gamma}}{1-\gamma}\right]\]</div>
<p>subject to</p>
<div class="math notranslate nohighlight">
\[c_{t}^{i}+p_{t}^{s}s_{t+1}^{i}+p_{t}^{b}b_{t+1}^{i}\leq(p_{t}^{s}+d_{t})s_{t}^{i}+b_{t}^{i}+Y_{t}^{i}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}s_{t+1}^{i} &amp; \geq0, \\
b_{t+1}^{i} &amp; \geq K^b_t,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(Y^a_t\)</span> denotes the aggregate income. <span class="math notranslate nohighlight">\(d_t = \delta_t Y^a_t\)</span> is total dividend (capital income) and
<span class="math notranslate nohighlight">\(Y^i_t = \eta^i_t Y^a_t\)</span> is labor income of agent <span class="math notranslate nohighlight">\(i\)</span>. Aggregate income grows at a stochastic rate <span class="math notranslate nohighlight">\(\gamma^a_t = \frac{Y^a_t}{Y^a_{t-1}}\)</span>. <span class="math notranslate nohighlight">\(z_t = \{\gamma^a_t,\delta_t,\eta^1_t\}\)</span>
follows a first-order Markov process estimated using U.S. data. The borrowing limit is set to be a constant fraction of per capita income, i.e.,
<span class="math notranslate nohighlight">\(K^b_t = \bar{K}^b Y^a_t\)</span>.</p>
<p>In equilibrium, prices are determined such that markets clear in each
shock history:</p>
<div class="math notranslate nohighlight">
\[\begin{split}&amp; s_{t}^{1}+s_{t}^{2}=1,\\
&amp; b_{t}^{1}+b_{t}^{2}=0.\end{split}\]</div>
<p>We use the financial wealth share</p>
<div class="math notranslate nohighlight">
\[\omega_{t}^{i}=\frac{(p_{t}^{s}+d_{t})s_{t}^{i}+b_{t}^{i}}{p_{t}^{s}+d_{t}}\]</div>
<p>as an endogenous state variable. In equilibrium, the market clearing conditions imply that <span class="math notranslate nohighlight">\(\omega^1_t + \omega^2_t = 1\)</span>.</p>
<p>For any variable <span class="math notranslate nohighlight">\(x_t\)</span>,
let <span class="math notranslate nohighlight">\(\hat{x}_t\)</span> denote the normalized variable: <span class="math notranslate nohighlight">\(\hat{x}_t=\frac{x_t}{Y^a_t}\)</span>
(except <span class="math notranslate nohighlight">\(b^i_t\)</span> for which <span class="math notranslate nohighlight">\(\hat{b}^i_t = \frac{b^i_t}{Y^a_{t-1}}\)</span>). Using this normalization, agent i’s budget constraint can be rewritten as</p>
<div class="math notranslate nohighlight">
\[\hat{c}_{t}^{i}+\hat{p}_{t}^{s}s_{t+1}^{i}+p_{t}^{b}\hat{b}_{t+1}^{i}\leq\left(\hat{p}_{t}^{s}+\hat{d}_{t}\right)\omega_{t}^{i}+\hat{Y}_{t}^{i}.\]</div>
<p>The financial wealth share is rewritten as</p>
<div class="math notranslate nohighlight">
\[\omega_{t}^{i}=\frac{(\hat{p}_{t}^{s}+\hat{d}_{t})s_{t}^{i}+\frac{\hat{b}_{t}^{i}}{\gamma^a_t}}{\hat{p}_{t}^{s}+\hat{d}_{t}}.\]</div>
<p>The optimality of agent i’s consumption and asset choices is captured by
the first-order conditions in <span class="math notranslate nohighlight">\(s^i_{t+1}\)</span> and <span class="math notranslate nohighlight">\(b^i_{t+1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}1&amp; =\beta\mathbb{E}_{t}\left[\left(\frac{\hat{c}_{t+1}^{i}}{\hat{c}^i_t}\right)^{-\gamma}\left(\gamma_{t+1}^{a}\right)^{1-\gamma}\frac{\hat{p}_{t+1}^{s}+\hat{d}_{t+1}}{\hat{p}_{t}^{s}}\right]+\hat{\mu}^{i,s}_t\\
1&amp; =\beta\mathbb{E}_{t}\left[\left(\frac{\hat{c}_{t+1}^{i}}{\hat{c}^i_t}\right)^{-\gamma}\left(\gamma_{t+1}^{a}\right)^{-\gamma}\frac{1}{p_{t}^{b}}\right]+\hat{\mu}^{i,b}_t,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\mu}^{i,s}_t\)</span> and <span class="math notranslate nohighlight">\(\hat{\mu}^{i,b}_t\)</span> are the Lagrangian multipliers on agent i’s no short sale constraint and borrowing constraint, respectively.
The multipliers and portfolio choices satisfy the complementary-slackness conditions:</p>
<div class="math notranslate nohighlight">
\[\begin{split}0 &amp; =  \hat{\mu}^{i,s}_t s^i_{t+1}, \\
0 &amp; = \hat{\mu}^{i,b}_t (\hat{b}^i_{t+1} - \bar{K}^b).\end{split}\]</div>
</section>
<section id="wealth-share-as-endogenous-state">
<h2>Wealth Share as Endogenous State<a class="headerlink" href="#wealth-share-as-endogenous-state" title="Permalink to this heading"></a></h2>
<p>We define a recursive equilibrium with the wealth share <span class="math notranslate nohighlight">\(\omega_t\)</span> defined before. A recursive equilibrium is
<span class="math notranslate nohighlight">\(\hat{c}^i(z,\omega), {s^i}', {\hat{b}^i}', \hat{\mu}^{i,s}, \hat{\mu}^{b,i}, p^s, p^b, \omega'(z';z,\omega)\)</span> that satisfy the agents’ optimization conditions
and market clearing conditions stated above.</p>
<p>We omit the explicit dependence on state <span class="math notranslate nohighlight">\((z,\omega)\)</span>, and highlight that the
the endogenous state variable <span class="math notranslate nohighlight">\(\omega'\)</span> features law of motions that are implicitly characterized by equations
which depend on future exogenous state variables <span class="math notranslate nohighlight">\(z'\)</span>.
It should be clear at this moment that the key feature of our framework that enables to cast the equilibrium system as a single equation system,
despite the non-trivial state-transition functions, is to include the state variable <span class="math notranslate nohighlight">\(\omega'(z')\)</span> for each realization of <span class="math notranslate nohighlight">\(z'\)</span> as unknowns.</p>
<p>The system can be implemented by the following <a class="reference download internal" download="" href="../../_downloads/791c376360c9be721407d670f16fbf7d/HL1996.gmod"><code class="xref download docutils literal notranslate"><span class="pre">HL1996.gmod</span></code></a> code</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c">% Parameters</span>
<span class="linenos"> 2</span><span class="k">parameters</span> beta gamma Kb;
<span class="linenos"> 3</span>beta = 0.95;  <span class="c">% discount factor</span>
<span class="linenos"> 4</span>gamma = 1.5;  <span class="c">% CRRA coefficient</span>
<span class="linenos"> 5</span>Kb = -0.05;   <span class="c">% borrowing limit in ratio of aggregate output</span>
<span class="linenos"> 6</span><span class="c">% Exogenous state variables</span>
<span class="linenos"> 7</span><span class="k">var_shock</span> g d eta1;
<span class="linenos"> 8</span><span class="c">% Enumerate exogenous states and transition matrix</span>
<span class="linenos"> 9</span><span class="k">shock_num</span> = 8;
<span class="linenos">10</span>g = [.9904 1.0470 .9904 1.0470 .9904 1.0470 .9904 1.0470];
<span class="linenos">11</span>d = [.1402 .1437 .1561 .1599 .1402 .1437 .1561 .1599];
<span class="linenos">12</span>eta1 = [.3772 .3772 .3772 .3772 .6228 .6228 .6228 .6228];
<span class="linenos">13</span><span class="k">shock_trans</span> = [
<span class="linenos">14</span>    0.3932 0.2245 0.0793 0.0453 0.1365 0.0779 0.0275 0.0158
<span class="linenos">15</span>    0.3044 0.3470 0.0425 0.0484 0.1057 0.1205 0.0147 0.0168
<span class="linenos">16</span>    0.0484 0.0425 0.3470 0.3044 0.0168 0.0147 0.1205 0.1057
<span class="linenos">17</span>    0.0453 0.0793 0.2245 0.3932 0.0157 0.0275 0.0779 0.1366
<span class="linenos">18</span>    0.1366 0.0779 0.0275 0.0157 0.3932 0.2245 0.0793 0.0453
<span class="linenos">19</span>    0.1057 0.1205 0.0147 0.0168 0.3044 0.3470 0.0425 0.0484
<span class="linenos">20</span>    0.0168 0.0147 0.1205 0.1057 0.0484 0.0425 0.3470 0.3044
<span class="linenos">21</span>    0.0158 0.0275 0.0779 0.1365 0.0453 0.0793 0.2245 0.3932
<span class="linenos">22</span>    ];
<span class="linenos">23</span><span class="c">% Endogenous state variables</span>
<span class="linenos">24</span>var_state w1;  <span class="c">% wealth share</span>
<span class="linenos">25</span>w1 = linspace(-0.05,1.05,201);
<span class="linenos">26</span><span class="c">% Policy variables and bounds that enter the equations</span>
<span class="linenos">27</span><span class="k">var_policy</span> c1 c2 s1p nb1p nb2p ms1 ms2 mb1 mb2 ps pb w1n[8];
<span class="linenos">28</span><span class="k">inbound</span> c1 0.05 1.0;
<span class="linenos">29</span><span class="k">inbound</span> c2 0.05 1.0;
<span class="linenos">30</span><span class="k">inbound</span> s1p 0.0 1.0;
<span class="linenos">31</span>inbound nb1p 0.0 1.0;   <span class="c">% nb1p=b1p-Kb</span>
<span class="linenos">32</span><span class="k">inbound</span> nb2p 0.0 1.0;   
<span class="linenos">33</span>inbound ms1 0 1;        <span class="c">% Multipliers for constraints</span>
<span class="linenos">34</span><span class="k">inbound</span> ms2 0 1;
<span class="linenos">35</span><span class="k">inbound</span> mb1 0 1;
<span class="linenos">36</span><span class="k">inbound</span> mb2 0 1;
<span class="linenos">37</span>inbound ps 0 3 <span class="k">adaptive</span>(1.5);
<span class="linenos">38</span>inbound pb 0 3 <span class="k">adaptive</span>(1.5);
<span class="linenos">39</span><span class="k">inbound</span> w1n -0.5 1.5;
<span class="linenos">40</span><span class="c">% Other policy variables</span>
<span class="linenos">41</span><span class="k">var_aux</span> equity_premium;
<span class="linenos">42</span><span class="c">% Interpolation variables for policy and state transitions</span>
<span class="linenos">43</span><span class="k">var_interp</span> ps_future c1_future c2_future;
<span class="linenos">44</span><span class="k">initial</span> ps_future 0.0;
<span class="linenos">45</span><span class="k">initial</span> c1_future w1.*d+eta1;
<span class="linenos">46</span><span class="k">initial</span> c2_future (1-w1).*d+1-eta1;
<span class="linenos">47</span>ps_future = ps;
<span class="linenos">48</span>c1_future = c1;
<span class="linenos">49</span>c2_future = c2;
<span class="linenos">50</span>
<span class="linenos">51</span><span class="k">model;</span>
<span class="linenos">52</span>  <span class="c">% Evaluate interpolation</span>
<span class="linenos">53</span>  [psn&#39;,c1n&#39;,c2n&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>(w1n&#39;);
<span class="linenos">54</span>  <span class="c">% Calculate expectations that enter the Euler Equations</span>
<span class="linenos">55</span>  es1 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c1n&#39;/c1)^(-gamma)*(psn&#39;+d&#39;)/ps};
<span class="linenos">56</span>  es2 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c2n&#39;/c2)^(-gamma)*(psn&#39;+d&#39;)/ps};
<span class="linenos">57</span>  eb1 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c1n&#39;/c1)^(-gamma)/pb};
<span class="linenos">58</span>  eb2 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c2n&#39;/c2)^(-gamma)/pb};
<span class="linenos">59</span>  <span class="c">% Transform bond back</span>
<span class="linenos">60</span>  b1p = nb1p + Kb;
<span class="linenos">61</span>  b2p = nb2p + Kb;
<span class="linenos">62</span>  <span class="c">% Market clearing of shares</span>
<span class="linenos">63</span>  s2p = 1-s1p;
<span class="linenos">64</span>  <span class="c">% Budget constraints</span>
<span class="linenos">65</span>  budget_1 = w1*(ps+d)+eta1 - c1 - ps*s1p - pb*b1p;
<span class="linenos">66</span>  budget_2 = (1-w1)*(ps+d)+(1-eta1) - c2 - ps*s2p - pb*b2p;
<span class="linenos">67</span>  <span class="c">% Consistency equations</span>
<span class="linenos">68</span>  w1_consis&#39; = (s1p*(psn&#39;+d&#39;) + b1p/g&#39;)/(psn&#39;+d&#39;) - w1n&#39;;
<span class="linenos">69</span>  <span class="c">% Other policy variables</span>
<span class="linenos">70</span>  equity_premium = <span class="k">GDSGE_EXPECT</span>{(psn&#39;+d&#39;)/ps*g&#39;} - 1/pb;
<span class="linenos">71</span>  <span class="k">equations;</span>
<span class="linenos">72</span>    -1+beta*es1+ms1;
<span class="linenos">73</span>    -1+beta*es2+ms2;
<span class="linenos">74</span>    -1+beta*eb1+mb1;
<span class="linenos">75</span>    -1+beta*eb2+mb2;
<span class="linenos">76</span>    ms1*s1p;
<span class="linenos">77</span>    ms2*s2p;
<span class="linenos">78</span>    mb1*nb1p;
<span class="linenos">79</span>    mb2*nb2p;
<span class="linenos">80</span>    b1p+b2p;
<span class="linenos">81</span>    budget_1/w1;        <span class="c">% Normalized by total budget</span>
<span class="linenos">82</span>    budget_2/(1-w1);
<span class="linenos">83</span>    w1_consis&#39;;
<span class="linenos">84</span>  <span class="k">end;</span>
<span class="linenos">85</span><span class="k">end;</span>
<span class="linenos">86</span>
<span class="linenos">87</span><span class="k">simulate;</span>
<span class="linenos">88</span>  <span class="k">num_periods</span> = 10000;
<span class="linenos">89</span>  <span class="k">num_samples</span> = 6;
<span class="linenos">90</span>  <span class="k">initial</span> w1 0.5;
<span class="linenos">91</span>  <span class="k">initial</span> shock 1;
<span class="linenos">92</span>  <span class="k">var_simu</span> c1 c2 ps pb equity_premium ms1 mb1;
<span class="linenos">93</span>  w1&#39; = w1n&#39;;
<span class="linenos">94</span><span class="k">end;</span>
</pre></div>
</div>
<p>As shown, the implicit law of motion for the endogenous state <span class="math notranslate nohighlight">\(\omega'\)</span> is captured by the consistency equation</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">68</span>  w1_consis&#39; = (s1p*(psn&#39;+d&#39;) + b1p/g&#39;)/(psn&#39;+d&#39;) - w1n&#39;;
</pre></div>
</div>
<p>which says that the future wealth share <span class="math notranslate nohighlight">\(\omega'\)</span> should be consistent with the current choices of stock and bond holdings,
the future stock price—which is itself a function of <span class="math notranslate nohighlight">\(\omega'\)</span>, and the realization of future exogenous states, state by state.
Notice that unknowns <span class="math notranslate nohighlight">\(\omega'\)</span> are the inputs
in interpolating the last-iteration policy functions to forecast future consumption and stock price, which are required to formulate the recursive system, in</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">53</span>  [psn&#39;,c1n&#39;,c2n&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>(w1n&#39;);
</pre></div>
</div>
<p>Accordingly, <span class="math notranslate nohighlight">\(\omega'\)</span> is declared to be a vector of unknowns in</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">27</span><span class="k">var_policy</span> c1 c2 s1p nb1p nb2p ms1 ms2 mb1 mb2 ps pb w1n[8];
</pre></div>
</div>
<p>and the consistency equations are declared to be part of the equation system in</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">83</span>    w1_consis&#39;;
</pre></div>
</div>
<p>Since now the transition of the endogenous state <span class="math notranslate nohighlight">\(\omega\)</span> depends on the realization of future exogenous states,
in the simulation, we need to specify that the transition depends on the realization of future states as</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">93</span>  w1&#39; = w1n&#39;;
</pre></div>
</div>
<p>Notice the prime operator in <em>w1n’</em>, which is the syntax to specify the transition’s dependence on the
realization of future exogenous states (recall, <em>w1n</em> is a vector solved from the policy iteration as one of the <em>var_policy</em>).</p>
<p>Now we discuss several tricks that facilitate casting the recursive system to the toolbox, which are commonly
used for this class of models.</p>
<p>Since the original problem’s borrowing constraint is proportional to the aggregate endowment, we can use transformations below
to simplify the constraint</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">60</span>  b1p = nb1p + Kb;
<span class="linenos">61</span>  b2p = nb2p + Kb;
</pre></div>
</div>
<p>where <em>Kb</em> is the parameter governing the borrowing constraint in fraction of the aggregate endowment (<span class="math notranslate nohighlight">\(b^i \geq Kb * Y^a\)</span>), and <em>nb1p</em> is the unknown defined as
<span class="math notranslate nohighlight">\(nb^i=\hat{b}^i+Kb\)</span> which is required to be positive. Such transformation
remains trivial in the current problem, but becomes crucial when the borrowing constraint depends on an asset price, which makes the constraint
not necessarily a box constraint. See example <a class="reference internal" href="../KM1997/CaoNie2017.html#caonie2017"><span class="std std-ref">Cao and Nie (2017)</span></a>, which provides a global solution to a <a class="reference external" href="https://www.journals.uchicago.edu/doi/abs/10.1086/262072">Kiyotaki-Moore</a> type model, where
the borrowing constraint is tied to the price of an asset in fixed supply.</p>
<p>Some built-in functions of the toolbox are used in this example.</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">53</span>  [psn&#39;,c1n&#39;,c2n&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>(w1n&#39;);
</pre></div>
</div>
<p><em>GDSGE_INTERP_VEC</em> is a built-in function that evaluates function approximations for policy and state transition functions
defined in <em>var_interp</em> once for all. The results are returned according to the order of variables defined in <em>var_interp</em>.
The prime operator following <em>GDSGE_INTERP_VEC</em> indicates that the approximation is done for each realization of the exogenous states.
Accordingly, the returned values are vectors (of length 8 in the current example) corresponding to each realization of the future exogenous states.
This step can be replaced by</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span>psn&#39; = ps_future&#39;(w1n&#39;);
c1n&#39; = c1_future&#39;(w1n&#39;);
c2n&#39; = c2_future&#39;(w1n&#39;);
</pre></div>
</div>
<p>although at a lower speed since <em>GDSGE_INTERP_VEC</em> evaluates function approximations with vectorization. (This is particular relevant
when using the adaptive sparse grid method as the coefficients are stored in a table with each entry referring to
the coefficients across all vector dimensions. Therefore, using <em>GDSGE_INTERP_VEC</em> instead of individual evaluations
not only enables vectorization but also allows searching the table only once). <em>GDSGE_INTERP_VEC</em> can also skip
certain variables in <em>var_interp</em> when some of them are not necessary, and can be used without the prime operator but
explicitly specifying the exogenous state that the approximation should be evaluated. This is relevant when
the expectation can be calculated before evaluating the equation system, so the evaluation is conditional on the current state.
See example <a class="reference internal" href="../Guvenen2009/Guvenen2009.html#guvenen2009"><span class="std std-ref">Guvenen (2009)</span></a> for an example.</p>
<p>After the gmod file is parsed and compiled by the <a class="reference external" href="http://www.gdsge.com">online compiler</a>, first call the iter file in MATLAB, which produces
the following results</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt;&gt; IterRslt = iter_HL1996;

Iter:10, Metric:0.133835, maxF:7.07521e-09
Elapsed time is 8.338626 seconds.

...

Iter:209, Metric:9.56568e-07, maxF:8.69762e-09
Elapsed time is 0.443740 seconds.
</pre></div>
</div>
<p>We can inspect the policy functions (e.g., for the equity premium declared as <em>var_aux</em> in Line 41 and defined in Line 70):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt;&gt; figure;
plot(IterRslt.var_state.w1, IterRslt.var_aux.equity_premium*100,&#39;LineWidth&#39;,1.5);
title(&#39;Equity Premium&#39;);
xlabel(&#39;Wealth Share of Agent 1&#39;);
ylabel(&#39;%&#39;);
</pre></div>
</div>
<p>which produces</p>
<a class="reference internal image-reference" href="../../_images/policy_equity_premium1.png"><img alt="../../_images/policy_equity_premium1.png" src="../../_images/policy_equity_premium1.png" style="width: 389.6px; height: 325.6px;" /></a>
<p>The policy functions demonstrate the non-linear and non-monotone properties of the model. These non-linear regions appear with
positive probability in the model’s ergodic set as shown below.</p>
<p>We can simulate the model using the converged policy and state transition functions contained in <em>IterRslt</em>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt;&gt; SimuRslt = simulate_HL1996(IterRslt);

Periods: 1000
shock      w1      c1      c2      ps      pbequity_premium
    1  0.7879  0.6058  0.5344    2.48  0.93240.001541
Elapsed time is 2.077381 seconds.
Periods: 2000
shock      w1      c1      c2      ps      pbequity_premium
    1  0.7147  0.5925  0.5477   2.469  0.93220.001442
Elapsed time is 1.478454 seconds.

...

Periods: 10000
shock      w1      c1      c2      ps      pbequity_premium
    3  0.2948  0.5243  0.6318   2.553  0.92950.001643
Elapsed time is 1.488598 seconds.
</pre></div>
</div>
<p>And inspect the simulation results:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&gt;&gt; figure;
histogram(SimuRslt.w1(:,1000:end),50,&#39;Normalization&#39;,&#39;probability&#39;);
title(&#39;Histogram of Wealth Share in the Ergodic Distribution&#39;);
xlabel(&#39;Wealth Share of Agent 1&#39;);
ylabel(&#39;Fractions&#39;);
</pre></div>
</div>
<p>which produces</p>
<a class="reference internal image-reference" href="../../_images/histogram_w11.png"><img alt="../../_images/histogram_w11.png" src="../../_images/histogram_w11.png" style="width: 614.8000000000001px; height: 500.40000000000003px;" /></a>
<p>The spikes in the ergodic distribution of wealth share at the two ends imply that the constraints are occasionally binding.</p>
</section>
<section id="evaluate-the-accuracy-of-solutions">
<h2>Evaluate the Accuracy of Solutions<a class="headerlink" href="#evaluate-the-accuracy-of-solutions" title="Permalink to this heading"></a></h2>
<p>The converged policy iterations deliver both the policy functions and the state transition functions, which can be used conveniently to evaluate
the accuracy of the solutions by e.g., inspecting the Euler equation errors. Define the unit-free Euler equation errors for shares and bonds as</p>
<div class="math notranslate nohighlight">
\[\begin{split}&amp; \mathcal{E}^{s,i}_t = -1 + \beta\mathbb{E}_{t}\left[\left(\frac{\hat{c}_{t+1}^{i}}{\hat{c}^i_t}\right)^{-\gamma}\left(\gamma_{t+1}^{a}\right)^{1-\gamma}\frac{\hat{p}_{t+1}^{s}+\hat{d}_{t+1}}{\hat{p}_{t}^{s}}\right]+\hat{\mu}^{i,s}_t\\
&amp; \mathcal{E}^{b,i}_t = -1 + \beta\mathbb{E}_{t}\left[\left(\frac{\hat{c}_{t+1}^{i}}{c^i_t}\right)^{-\gamma}\left(\gamma_{t+1}^{a}\right)^{-\gamma}\frac{1}{p_{t}^{b}}\right]+\hat{\mu}^{i,b}_t.\end{split}\]</div>
<p>And we are to evaluate these errors starting from a simulated ergodic set of states. Due to symmetry, we focus on Agent 1 only.
This can be done by simulating, starting from the ergodic set, for one period forward, and evaluating these errors according to the equations defined above
using the simulated paths. In particular, to calculate the expectation of the objects in the equations along the simulated path, we should use
the exact transition path for integration to eliminate sampling errors.</p>
<p>The MATLAB code that implements the above procedure is listed below (or download <a class="reference download internal" download="" href="../../_downloads/deeff035c8b97c7252a6b3c5d20a1ca2/eval_euler_errors.m"><code class="xref download docutils literal notranslate"><span class="pre">eval_euler_errors.m</span></code></a>), which should be self-explanatory with the documentation contained.</p>
<div class="highlight-MATLAB notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c">% Extract the ergodic set</span><span class="w"></span>
<span class="linenos"> 2</span><span class="n">NUM_PERIODS</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="n">w1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">reshape</span><span class="p">(</span><span class="n">SimuRslt</span><span class="p">.</span><span class="n">w1</span><span class="p">(:,</span><span class="k">end</span><span class="o">-</span><span class="n">NUM_PERIODS</span><span class="p">:</span><span class="k">end</span><span class="p">),</span><span class="mi">1</span><span class="p">,[]);</span><span class="w"></span>
<span class="linenos"> 4</span><span class="n">shock</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">reshape</span><span class="p">(</span><span class="n">SimuRslt</span><span class="p">.</span><span class="n">shock</span><span class="p">(:,</span><span class="k">end</span><span class="o">-</span><span class="n">NUM_PERIODS</span><span class="p">:</span><span class="k">end</span><span class="p">),</span><span class="mi">1</span><span class="p">,[]);</span><span class="w"></span>
<span class="linenos"> 5</span><span class="c">% Replicate the sample to accommodate future shock realizations</span><span class="w"></span>
<span class="linenos"> 6</span><span class="n">w1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">repmat</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">shock_num</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 7</span><span class="n">shock1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">repmat</span><span class="p">(</span><span class="n">shock</span><span class="p">,</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">shock_num</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos"> 8</span><span class="n">shock2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">repmat</span><span class="p">([</span><span class="mi">1</span><span class="p">:</span><span class="n">IterRslt</span><span class="p">.</span><span class="n">shock_num</span><span class="p">]</span><span class="o">&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">size</span><span class="p">(</span><span class="n">w1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="c">% Simulate forward for one period</span><span class="w"></span>
<span class="linenos">11</span><span class="n">simuOptions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">struct</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="n">simuOptions</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">w1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">w1</span><span class="p">(:);</span><span class="w"></span>
<span class="linenos">13</span><span class="n">simuOptions</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">shock</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="n">shock1</span><span class="p">(:),</span><span class="n">shock2</span><span class="p">(:)];</span><span class="w"></span>
<span class="linenos">14</span><span class="c">% The following line states that the first two-period shock indexes are</span><span class="w"></span>
<span class="linenos">15</span><span class="c">% supplied and not regenerated</span><span class="w"></span>
<span class="linenos">16</span><span class="n">simuOptions</span><span class="p">.</span><span class="n">GEN_SHOCK_START_PERIOD</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="n">simuOptions</span><span class="p">.</span><span class="n">num_samples</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">numel</span><span class="p">(</span><span class="n">w1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">18</span><span class="n">simuOptions</span><span class="p">.</span><span class="n">num_periods</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">    </span><span class="c">% One-period forecasting error</span><span class="w"></span>
<span class="linenos">19</span><span class="c">% The following line simulates one period forward by starting from w1 and</span><span class="w"></span>
<span class="linenos">20</span><span class="c">% shock contained in simuOptions</span><span class="w"></span>
<span class="linenos">21</span><span class="n">simuForward</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simulate_HL1996</span><span class="p">(</span><span class="n">IterRslt</span><span class="p">,</span><span class="n">simuOptions</span><span class="p">);</span><span class="w"></span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="c">% Calculate Errors</span><span class="w"></span>
<span class="linenos">24</span><span class="nb">beta</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IterRslt</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">beta</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="nb">gamma</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IterRslt</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">gamma</span><span class="p">;</span><span class="w"></span>
<span class="linenos">26</span><span class="n">c1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simuForward</span><span class="p">.</span><span class="n">c1</span><span class="p">(:,</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">c1n</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simuForward</span><span class="p">.</span><span class="n">c1</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="linenos">27</span><span class="n">ps</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simuForward</span><span class="p">.</span><span class="n">ps</span><span class="p">(:,</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">psn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simuForward</span><span class="p">.</span><span class="n">ps</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="linenos">28</span><span class="n">pb</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simuForward</span><span class="p">.</span><span class="n">pb</span><span class="p">(:,</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">29</span><span class="n">ms1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simuForward</span><span class="p">.</span><span class="n">ms1</span><span class="p">(:,</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">mb1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">simuForward</span><span class="p">.</span><span class="n">mb1</span><span class="p">(:,</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">30</span><span class="n">gn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_shock</span><span class="p">.</span><span class="n">g</span><span class="p">(</span><span class="n">shock2</span><span class="p">(:))</span><span class="o">&#39;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">31</span><span class="n">dn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IterRslt</span><span class="p">.</span><span class="n">var_shock</span><span class="p">.</span><span class="n">d</span><span class="p">(</span><span class="n">shock2</span><span class="p">(:))</span><span class="o">&#39;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">32</span><span class="n">es1_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">beta</span><span class="o">*</span><span class="n">gn</span><span class="o">.^</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nb">gamma</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="n">c1n</span><span class="o">./</span><span class="n">c1</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="n">psn</span><span class="o">+</span><span class="n">dn</span><span class="p">)</span><span class="o">./</span><span class="n">ps</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ms1</span><span class="p">;</span><span class="w"></span>
<span class="linenos">33</span><span class="n">eb1_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">beta</span><span class="o">*</span><span class="n">gn</span><span class="o">.^</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="p">)</span><span class="o">.*</span><span class="p">(</span><span class="n">c1n</span><span class="o">./</span><span class="n">c1</span><span class="p">)</span><span class="o">.^</span><span class="p">(</span><span class="o">-</span><span class="nb">gamma</span><span class="p">)</span><span class="o">./</span><span class="n">pb</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mb1</span><span class="p">;</span><span class="w"></span>
<span class="linenos">34</span><span class="c">% Calculate expectation errors, integrating using the transition matrix</span><span class="w"></span>
<span class="linenos">35</span><span class="n">shock_trans</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IterRslt</span><span class="p">.</span><span class="n">shock_trans</span><span class="p">(</span><span class="n">shock</span><span class="p">,:)</span><span class="o">&#39;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">36</span><span class="n">shock_num</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IterRslt</span><span class="p">.</span><span class="n">shock_num</span><span class="p">;</span><span class="w"></span>
<span class="linenos">37</span><span class="n">es1_expect_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="n">shock_trans</span><span class="o">.*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">es1_error</span><span class="p">,</span><span class="n">shock_num</span><span class="p">,[]),</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">38</span><span class="n">max_abs_es1_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">es1_expect_error</span><span class="p">))</span><span class="w"></span>
<span class="linenos">39</span><span class="n">mean_abs_es1_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">es1_expect_error</span><span class="p">))</span><span class="w"></span>
<span class="linenos">40</span><span class="n">eb1_expect_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="n">shock_trans</span><span class="o">.*</span><span class="nb">reshape</span><span class="p">(</span><span class="n">eb1_error</span><span class="p">,</span><span class="n">shock_num</span><span class="p">,[]),</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">41</span><span class="n">max_abs_eb1_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">eb1_expect_error</span><span class="p">))</span><span class="w"></span>
<span class="linenos">42</span><span class="n">mean_abs_eb1_error</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">eb1_expect_error</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>Running the code produces:</p>
<div class="highlight-MATLAB notranslate"><div class="highlight"><pre><span></span><span class="n">max_abs_es1_error</span><span class="w"> </span><span class="p">=</span><span class="w"></span>

<span class="w">    </span><span class="mf">0.0057</span><span class="w"></span>


<span class="n">mean_abs_es1_error</span><span class="w"> </span><span class="p">=</span><span class="w"></span>

<span class="mf">2.5290e-05</span><span class="w"></span>


<span class="n">max_abs_eb1_error</span><span class="w"> </span><span class="p">=</span><span class="w"></span>

<span class="w">    </span><span class="mf">0.0036</span><span class="w"></span>


<span class="n">mean_abs_eb1_error</span><span class="w"> </span><span class="p">=</span><span class="w"></span>

<span class="mf">2.1279e-05</span><span class="w"></span>
</pre></div>
</div>
<p>which says that the max and mean absolute errors (across states in the ergodic distribution)
for stock Euler equations are <em>0.0057</em> and <em>2.5290e-05</em> respectively, and the max and mean
absolute errors for bond Euler equations are <em>0.0036</em> and <em>2.1279e-05</em> respectively.</p>
<p>These are relatively errors in marginal utility, to convert them into relative errors in consumption,
we just need to multiply them by <span class="math notranslate nohighlight">\(1/\gamma\)</span>.
Therefore, the max and mean absolute errors in stock holding decisions are $38 and $0.169 per $10,000 in consumption.
The max and mean absolute errors in bond holding decisions are $24 and $0.142 per $10,000 in consumption.</p>
<p>Increasing the number of grid points reduces the errors. For example, increasing the number of grid points
to 1000 reduces the max absolute (Euler equation) errors below 1e-3 and mean absolute errors below 1e-5. However, a more effective approach is to use the adaptive-grid interpolation method included in the toolbox. Applying to the current model, the method reduces the max absolute errors below 1e-5 and mean absolute errors below 1e-6, with the number of grid points
smaller than 1000. The user only needs to specify a one-line option to enable the adaptive-grid method, but does need to initialize <em>var_interp</em> with a more flexible <em>model_init</em> block.
See example <a class="reference internal" href="../Bianchi2011/Bianchi2011.html#bianchi2011"><span class="std std-ref">Bianchi (2011)</span></a> for how to define a <em>model_init</em> block and apply the adaptive-grid method.</p>
</section>
<section id="consumption-share-as-the-endogenous-state">
<h2>Consumption Share as the Endogenous State<a class="headerlink" href="#consumption-share-as-the-endogenous-state" title="Permalink to this heading"></a></h2>
<p>The model can be solved using consumption share as the endogenous state. In this case, the budget constraint</p>
<div class="math notranslate nohighlight">
\[\hat{c}_{t+1}^i=s_{t+1}^i (\hat{p}_{t+1}^s + \hat{d}_{t+1})+ \frac{\hat{b}_{t+1}^i  }{g_{t+1}}+
\underbrace{\eta_{t+1}^i - \hat{p}_{t+1}^s s_{t+2}^i-p_{t+1}^b \hat{b}_{t+2}^i}_{\text{Financial Wealth}_{t+1}}\]</div>
<p>is a natural consistency equation for the transition of consumption share <span class="math notranslate nohighlight">\(\hat{c}^1\)</span>. Specifically, with consumption share,
the recursive equilibrium can be defined as <span class="math notranslate nohighlight">\({s^i}'(z,\hat{c}^1),{\hat{b}^i}'(z,\hat{c}^1), \hat{p}^s(z,\hat{c}^1),p^b(z,\hat{c}^1), {\hat{c}^1}'(z';z,\hat{c}^1)\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}-1+\beta  \mathbb{E}_t
\Big[\gamma^{1-\gamma}_{t+1}\frac{[\hat{c}_{t+1}^i]^{-\gamma}}{[\hat{c}_t^i]^{-\gamma} }  \frac{\hat{p}_{t+1}^s + \hat{d}_{t+1}}{\hat{p}_t^s}] + \hat{\mu}^{i,s}_t=0, \forall i=1,2
\\
-1+\beta  \mathbb{E}_t
\Big[\gamma_{t+1}^{-\gamma}\frac{[\hat{c}_{t+1}^i]^{-\gamma}}{[\hat{c}_t^i]^{-\gamma} }  \frac{1}{{p}_t^b}\Big] + \hat{\mu}^{i,b}_t=0, \forall i=1,2
\\
\hat{b}_{t+1}^1+\hat{b}_{t+1}^2=0
\\
s_{t+1}^1+s_{t+1}^2=1
\\
\hat{c}^1_{t+1}=s_{t+1}^i (\hat{p}_{t+1}^s + \hat{d}_{t+1})+ \frac{\hat{b}_{t+1}^i  }{\gamma_{t+1}}+
\underbrace{\eta_{t+1}^i - \hat{p}_{t+1}^s s_{t+2}^i-p_{t+1}^b \hat{b}_{t+2}^i}_{\text{Financial Wealth}_{t+1}}, \forall z_{t+1}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{c}^2\)</span> (and <span class="math notranslate nohighlight">\((\hat{c}^2)'\)</span>) can be trivially inferred from the goods market clearing condition <span class="math notranslate nohighlight">\(\hat{c}^1+\hat{c}^2=1 +\hat{d}\)</span>, and, hence does not
need to be defined as extra unknowns when evaluating the equation system.  The “Financial Wealth” is a function of future endogenous states, and can be part of the policy functions, returned as one of var_aux at each iteration.</p>
<p>The gmod file that implements the recursive system is (<a class="reference download internal" download="" href="../../_downloads/1f6eecd08470e535f34c08592cd8fdd4/HL1996_consumption_share.gmod"><code class="xref download docutils literal notranslate"><span class="pre">HL1996_consumption_share.gmod</span></code></a>)</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c">% Parameters</span>
<span class="linenos"> 2</span><span class="k">parameters</span> beta gamma Kb;
<span class="linenos"> 3</span>beta = 0.95;  <span class="c">% discount factor</span>
<span class="linenos"> 4</span>gamma = 1.5;  <span class="c">% CRRA coefficient</span>
<span class="linenos"> 5</span>Kb = -0.05;   <span class="c">% borrowing limit in ratio of aggregate output</span>
<span class="linenos"> 6</span><span class="c">% Exogenous state variables</span>
<span class="linenos"> 7</span><span class="k">var_shock</span> g d eta1;
<span class="linenos"> 8</span><span class="c">% Enumerate exogenous states and transition matrix</span>
<span class="linenos"> 9</span><span class="k">shock_num</span> = 8;
<span class="linenos">10</span>g = [.9904 1.0470 .9904 1.0470 .9904 1.0470 .9904 1.0470];
<span class="linenos">11</span>d = [.1402 .1437 .1561 .1599 .1402 .1437 .1561 .1599];
<span class="linenos">12</span>eta1 = [.3772 .3772 .3772 .3772 .6228 .6228 .6228 .6228];
<span class="linenos">13</span><span class="k">shock_trans</span> = [
<span class="linenos">14</span>    0.3932 0.2245 0.0793 0.0453 0.1365 0.0779 0.0275 0.0158
<span class="linenos">15</span>    0.3044 0.3470 0.0425 0.0484 0.1057 0.1205 0.0147 0.0168
<span class="linenos">16</span>    0.0484 0.0425 0.3470 0.3044 0.0168 0.0147 0.1205 0.1057
<span class="linenos">17</span>    0.0453 0.0793 0.2245 0.3932 0.0157 0.0275 0.0779 0.1366
<span class="linenos">18</span>    0.1366 0.0779 0.0275 0.0157 0.3932 0.2245 0.0793 0.0453
<span class="linenos">19</span>    0.1057 0.1205 0.0147 0.0168 0.3044 0.3470 0.0425 0.0484
<span class="linenos">20</span>    0.0168 0.0147 0.1205 0.1057 0.0484 0.0425 0.3470 0.3044
<span class="linenos">21</span>    0.0158 0.0275 0.0779 0.1365 0.0453 0.0793 0.2245 0.3932
<span class="linenos">22</span>    ];
<span class="linenos">23</span><span class="c">% Endogenous state variables</span>
<span class="linenos">24</span>var_state c1;  <span class="c">% consumption</span>
<span class="linenos">25</span>c1 = linspace(0.2,0.8,101);
<span class="linenos">26</span><span class="c">% Policy variables and bounds that enter the equations</span>
<span class="linenos">27</span><span class="k">var_policy</span> s1p nb1p nb2p ms1 ms2 mb1 mb2 ps pb c1n[8];
<span class="linenos">28</span><span class="k">inbound</span> s1p 0.0 1.0;
<span class="linenos">29</span>inbound nb1p 0.0 1.0;   <span class="c">% nb1p=b1p-Kb</span>
<span class="linenos">30</span><span class="k">inbound</span> nb2p 0.0 1.0;   
<span class="linenos">31</span>inbound ms1 0 1;        <span class="c">% Multipliers for constraints</span>
<span class="linenos">32</span><span class="k">inbound</span> ms2 0 1;
<span class="linenos">33</span><span class="k">inbound</span> mb1 0 1;
<span class="linenos">34</span><span class="k">inbound</span> mb2 0 1;
<span class="linenos">35</span>inbound ps 0 2 <span class="k">adaptive</span>(1.5);
<span class="linenos">36</span>inbound pb 0 2 <span class="k">adaptive</span>(1.5);
<span class="linenos">37</span><span class="k">inbound</span> c1n 0.0 1.0;
<span class="linenos">38</span><span class="c">% Other policy variables</span>
<span class="linenos">39</span><span class="k">var_aux</span> equity_premium c2 w1 flow;
<span class="linenos">40</span><span class="c">% Interpolation variables for policy and state transitions</span>
<span class="linenos">41</span><span class="k">var_interp</span> ps_future flow_future;
<span class="linenos">42</span><span class="k">initial</span> ps_future 0.0;
<span class="linenos">43</span><span class="k">initial</span> flow_future eta1;
<span class="linenos">44</span>ps_future = ps;
<span class="linenos">45</span>flow_future = flow;
<span class="linenos">46</span>
<span class="linenos">47</span><span class="k">model;</span>
<span class="linenos">48</span>  <span class="c">% Interpolation</span>
<span class="linenos">49</span>  [psn&#39;,flow_future&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>(c1n&#39;);
<span class="linenos">50</span>  <span class="c">% Goods market clear</span>
<span class="linenos">51</span>  c2n&#39; = 1+d&#39;-c1n&#39;;
<span class="linenos">52</span>  c2 = 1+d-c1;
<span class="linenos">53</span>  <span class="c">% Expectations in Euler Equations</span>
<span class="linenos">54</span>  es1 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c1n&#39;/c1)^(-gamma)*(psn&#39;+d&#39;)/ps};
<span class="linenos">55</span>  es2 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c2n&#39;/c2)^(-gamma)*(psn&#39;+d&#39;)/ps};
<span class="linenos">56</span>  eb1 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c1n&#39;/c1)^(-gamma)/pb};
<span class="linenos">57</span>  eb2 = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c2n&#39;/c2)^(-gamma)/pb};
<span class="linenos">58</span>  <span class="c">% Transform bond back</span>
<span class="linenos">59</span>  b1p = nb1p + Kb;
<span class="linenos">60</span>  b2p = nb2p + Kb;
<span class="linenos">61</span>  <span class="c">% Market clearing of shares</span>
<span class="linenos">62</span>  s2p = 1-s1p;
<span class="linenos">63</span>  <span class="c">% Budget constraints</span>
<span class="linenos">64</span>  budget_1 = w1*(ps+d)+eta1 - c1 - ps*s1p - pb*b1p;
<span class="linenos">65</span>  budget_2 = (1-w1)*(ps+d)+(1-eta1) - c2 - ps*s2p - pb*b2p;
<span class="linenos">66</span>  <span class="c">% Consistency equations</span>
<span class="linenos">67</span>  c1_consis&#39; = s1p*(psn&#39;+d&#39;) + b1p/g&#39; + flow_future&#39; - c1n&#39;;
<span class="linenos">68</span>  <span class="c">% Other policy variables</span>
<span class="linenos">69</span>  w1 = (c1 + ps*s1p + pb*b1p - eta1) / (ps + d);
<span class="linenos">70</span>  flow = eta1 - ps*s1p - pb*b1p;
<span class="linenos">71</span>  equity_premium = <span class="k">GDSGE_EXPECT</span>{(psn&#39;+d&#39;)/ps*g&#39;} - 1/pb;
<span class="linenos">72</span>  <span class="k">equations;</span>
<span class="linenos">73</span>    -1+beta*es1+ms1;
<span class="linenos">74</span>    -1+beta*es2+ms2;
<span class="linenos">75</span>    -1+beta*eb1+mb1;
<span class="linenos">76</span>    -1+beta*eb2+mb2;
<span class="linenos">77</span>    ms1*s1p;
<span class="linenos">78</span>    ms2*s2p;
<span class="linenos">79</span>    mb1*nb1p;
<span class="linenos">80</span>    mb2*nb2p;
<span class="linenos">81</span>    b1p+b2p;
<span class="linenos">82</span>    c1_consis&#39;;
<span class="linenos">83</span>  <span class="k">end;</span>
<span class="linenos">84</span><span class="k">end;</span>
<span class="linenos">85</span>
<span class="linenos">86</span><span class="k">simulate;</span>
<span class="linenos">87</span>  <span class="k">num_periods</span> = 10000;
<span class="linenos">88</span>  <span class="k">num_samples</span> = 24;
<span class="linenos">89</span>  <span class="k">initial</span> c1 0.5;
<span class="linenos">90</span>  <span class="k">initial</span> shock 1;
<span class="linenos">91</span>  <span class="k">var_simu</span> w1 c2 ps pb equity_premium;
<span class="linenos">92</span>  c1&#39; = c1n&#39;;
<span class="linenos">93</span><span class="k">end;</span>
</pre></div>
</div>
<p>As shown, compared to the one with wealth share as the endogenous state,
the new implementation is made possible by declaring <span class="math notranslate nohighlight">\({\hat{c}_1}'(z')\)</span> to be <em>c1n</em> in</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">27</span><span class="k">var_policy</span> s1p nb1p nb2p ms1 ms2 mb1 mb2 ps pb c1n[8];
</pre></div>
</div>
<p>by defining the “Financial Wealth” by <em>flow</em> as <em>var_interp</em></p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="k">var_interp</span> ps_future flow_future;
</pre></div>
</div>
<p>by defining the consistency equations for <span class="math notranslate nohighlight">\(\hat{c}_1'\)</span> in</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">67</span>  c1_consis&#39; = s1p*(psn&#39;+d&#39;) + b1p/g&#39; + flow_future&#39; - c1n&#39;;
</pre></div>
</div>
<p>and including them as part of the equation system.</p>
<p>Finally we compare the solutions solved with wealth share as the endogenous state and consumption share as the endogenous state.
This can be done by projecting the solutions to the same endogenous state. For example</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">69</span>  w1 = (c1 + ps*s1p + pb*b1p - eta1) / (ps + d);
</pre></div>
</div>
<p>constructs the wealth share from the budget constraint of Agent 1.</p>
<a class="reference internal image-reference" href="../../_images/policy_premium_overlapped.png"><img alt="../../_images/policy_premium_overlapped.png" src="../../_images/policy_premium_overlapped.png" style="width: 387.20000000000005px; height: 325.6px;" /></a>
<p>As shown, the two solutions (solid lines for wealth share as endogenous state and markers “X” for consumption share as endogenous state) are not visually
distinguishable.</p>
</section>
<section id="comparison-with-alternative-algorithms">
<h2>Comparison with Alternative Algorithms<a class="headerlink" href="#comparison-with-alternative-algorithms" title="Permalink to this heading"></a></h2>
<p>The Simultaneous Transition and Policy Function Iteration (STPFI) algorithm and toolbox especially demonstrates its strength at solving models with endogenous state variables that feature implicit laws of motions,
like the current one (here, wealth share is such a state).</p>
<p>We also compare the performance of the algorithm with alternative methods that can solve the current model. The results are summarized in the table below.</p>
<a class="reference internal image-reference" href="../../_images/Table1.png"><img alt="../../_images/Table1.png" src="../../_images/Table1.png" style="width: 678.3px; height: 487.9px;" /></a>
<p>As shown, Algorithms (1)-(3) use the STPFI algorithm, and show that higher accuracies can be achieved by using a denser grid at costs that increase
linearly in the number of grids, or, using an adaptive grid at lower costs.</p>
<p>Algorithm (4) is the transition function iteration (TFI) method developed by <a class="reference external" href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2748230">Elenev, et al. (2021)</a>.
This algorithm is also based on time iterations, but unlike ours which solves the transition and policy functions jointly in each iteration,
theirs fixes the state transition function implied by the policy functions solved from the previous iteration.
We implement this alternative algorithm with the same numerical routines (including the equation solver and function approximation procedure) in C++,
starting from the same initial  transition function,
and fine-tuned for maximum numerical efficiency—
e.g., we pre-compute the expectation terms when they do not depend on current policy variables under the fixed state transition functions
—so the performance of the two algorithms can be compared fairly.
Using dampened updating with a damping parameter of 0.25 (i.e., with weight 0.75 assigned to updated transition functions),
Algorithm (4) can converge successfully, and the Euler equation errors are comparable to STPFI.
However, the speed is significantly slower than STPFI,
mainly because their algorithm fixes the state transition function and does not allow the future endogenous state (in the current example, future wealth share)
to respond to current policy variables (share and  bond choices etc.),
which renders finding a solution to the equilibrium system more difficult.
A more detailed discussion and the implementation of TFI using the toolbox can be found at <a class="reference internal" href="HL1996TFIter.html#hl1996-tfi"><span class="std std-ref">here</span></a>.</p>
<p>The second alternative algorithm, (5) in the table, is the nested fixed point algorithm.
The algorithm proceeds in a nested loop,
with the inner loop solving for converged policy functions fixing the state transition function,
and the outer loop solving for the state transition function that is consistent with the one implied by the inner loop.
We find that such an algorithm is very unstable, and can only start to converge with a sufficient large dampening parameter for updating the transition function,
especially for early iterations. Even with a large dampening parameter (0.75) the algorithm can still only converge to a level of 5e-5
(measured by the metric between policy functions of adjacent iterations),
although the Euler equation errors are  close to those of the STPFI benchmark.
Due to its nested nature, the speed is also significantly slower than STPFI.
<a class="reference external" href="https://onlinelibrary.wiley.com/doi/abs/10.3982/ECTA6658">Guvenen (2009)</a> uses a similar nested fixed point algorithm for solving an asset pricing model with a richer setup.
We demonstrate how to solve the model in the toolbox and discuss the performance comparison in more detail <a class="reference internal" href="../Guvenen2009/Guvenen2009.html#guvenen2009"><span class="std std-ref">here</span></a>.</p>
<p>The third alternative algorithm,
(6) in the table,
is the one developed by <a class="reference external" href="https://www.jstor.org/stable/1555538#metadata_info_tab_contents">Kubler and Schmedders (2003)</a>
and is labeled as NFP-KS.
Like STPFI, their algorithm solves policy variables and future state variables at each time step that respect all short-run equilibrium conditions
but does this in a nested manner: in the inner nest the future state variables  are solved  to respect the consistency equations
with current policy variables fixed, and in the outer nest the policy  variables are searched to satisfy the remaining equilibrium conditions.
As shown in the table, the algorithm is  slower than STPFI, but  once converged under the same criterion,
delivers solutions with similar accuracies.
NFP-KS is slower because it incurs substantially higher number of evaluations of the consistency equations,
which outweigh the benefits of solving a smaller system of equations each time.</p>
<a class="reference internal image-reference" href="../../_images/TableR1.png"><img alt="../../_images/TableR1.png" src="../../_images/TableR1.png" style="width: 665.5500000000001px; height: 239.4px;" /></a>
<p>To understand what drives the difference in the performance across algorithms,
we have produced a detailed breakdown of computation costs of all
the listed algorithms. To summarize, the difference is mainly due to that
other algorithms  economize on evaluations of a subset of equilibrium conditions but require substantially more evaluations of  other conditions,
whereas the STPFI algorithm achieves a balance in evaluating all equilibrium conditions.</p>
<p>In more detail, all algorithms are based on time iterations, and at
each time step solve an equilibrium system of equations which involves
evaluating equilibrium conditions repeatedly. The equilibrium conditions
can be broken into three blocks: intra-temporal evaluations (i.e.,
market clearing conditions, budget constraints etc. which involve
only current equilibrium variables), inter-temporal evaluations (i.e.,
conditions which involve future variables—in particular—Euler
equations), and consistency equations; different algorithms have comparative
advantages in reducing the number of evaluations for a certain block.
As shown in Table R1, the STPFI algorithm solves the whole short-term
equilibrium system simultaneously, so the number of evaluations of
the three categories are equal. This offers a useful benchmark to
understand the costs of each computation block for a typical economic
model like the current one: the computation costs of intra-temporal
and inter-temporal evaluations, in terms of number of evaluations, are of the same order of magnitude
(the computation time of evaluating inter-temporal conditions is still higher since they involve evaluating function approximations
and integrations when constructing the expected values of future policies), whereas the costs of evaluating consistency equations are much smaller.
This observation makes it clear why the STPFI algorithm can be potentially
efficient: by including extra consistency equations in the equation
system, it enables  the whole short-term equilibrium system
to be solved in one step, and minimizes the number of evaluations of intra-temporal
and inter-temporal conditions.</p>
<p>To demonstrate this feature of the STPFI algorithm more clearly, let us compare
the baseline algorithm (Algorithm (1)) and the Transition Function
Iteration algorithm (TFI, Algorithm (4)). As described in detail in
the paper, the TFI algorithm fixes the state transition function implied
by the previous time step instead of solving a consistent one, and
only updates the state transition function at the end of a time step.
Such a design minimizes the number of evaluations for inter-temporal
evaluations, since the values of future state variables do not depend
on policy variables within a time step, and thus all the expectation
terms that enter the inter-temporal conditions are only evaluated
once and then fixed when solving the system of intra-temporal equilibrium
equations; also, the costs of evaluating consistency equations are
minimal as they are only required at the end of each time step when
updating the state transition function. However, such a design is
at the cost of increasing the number of intra-temporal evaluations,
since by fixing the value of future states instead of allowing them
to respond to current policy variables, the model is distant from
its true dynamics, which makes solving the remaining equilibrium system
rather difficult. This extra burden  imposed on intra-temporal evaluations
is huge: as shown in the table, the TFI algorithm requires intra-temporal
evaluations one order of magnitude more than the baseline, rendering
it a less effective algorithm for the current problem.</p>
<p>Similarly, the nested fixed point algorithm of  Kubler and
Schmedders (2003) (Algorithm (6)),
which solves consistency equations state by state as inner nested problems and the remaining system of equations as the outer problem,
is designed to reduce the system of equations to be solved simultaneously at a time.
However, due to the nested nature of the algorithm, the number of evaluations of consistency equations is one order of magnitude more than that required by the STPFI algorithm;
besides, evaluating consistency equations for the NFP-KS algorithm is also more costly, as it involves extra evaluations of  <em>off-equilibrium</em>
future share prices when searching for consistent future wealth shares in the inner loop—such evaluations of future share prices when using the STPFI algorithm do not incur extra costs,
because future share prices are also used in evaluating inter-temporal conditions, of which the computation costs are counted there.
This explains why NFP-KS is a slower algorithm for the current  problem.</p>
<p>The nested fixed point algorithm of Guvenen (2009) (Algorithm (5)) is the slowest as it involves solving an inner converged policy functions,
holding the state transition functions at the outer loop that are potentially distant from the equilibrium ones.
As shown, the required number of policy function iterations is much larger,
despite that later policy function iterations can converge in only a few steps using the “warm-up” solutions.
Besides, the nested iterative algorithm is not amenable  to an automated design,
and the toolbox needs to be combined with MATLAB code that is responsible for conducting the outer loops for transition function iterations.
This is why there is substantially more amount of time spent in the “other” category, as loops in MATLAB do not achieve the same performance as the toolbox,
of which the main computations are delegated to compiled C++ binaries.</p>
<p>In summary, the STPFI algorithm is more efficient for the current
model since it balances the number of evaluations of the three computation
blocks, and for the current model, the costs of evaluating inter-temporal and intra-temporal
evaluations are of the same order of magnitude. In other models where inter-temporal
evaluations are more costly, such as models involving many Euler equations
for multiple asset choices or with less complex intra-temporal conditions,
or in models where the number of policy variables is large so reducing the system of equations is of first-order importance,
the other algorithms may show their strength and likely to be superior.</p>
<section id="toolbox-enabled-by-stpfi">
<h3>Toolbox enabled by STPFI<a class="headerlink" href="#toolbox-enabled-by-stpfi" title="Permalink to this heading"></a></h3>
<p>Lastly, compared with nested algorithms such as NFP-KS (Algorithm (6)) and NFP-Guvenen (Algorithm (5)),
the non-nested feature of STPFI also makes it more amenable to an automated design, for which the current toolbox can be developed.
To demonstrate such an advantage, below we list the code that implements the NFP-KS algorithm as a comparison.
The implementation can actually be done using the toolbox, by manually inserting C++ codes that are used to solve the inner problem
(as a reminder, at each time step, the NFP-KS algorithm solves for consistent future endogenous states in the inner nest fixing values of policy variables,
and solves for policy variables in the outer nest.)</p>
<div class="highlight-GDSGE notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="c">% Parameters</span>
<span class="linenos">  2</span>cinclude(&#39;rtnewt.h&#39;);
<span class="linenos">  3</span>cinclude(&#39;stdlib.h&#39;);
<span class="linenos">  4</span><span class="k">parameters</span> beta gamma Kb;
<span class="linenos">  5</span>beta = 0.95;  <span class="c">% discount factor</span>
<span class="linenos">  6</span>gamma = 1.5;  <span class="c">% CRRA coefficient</span>
<span class="linenos">  7</span>Kb = -0.05;   <span class="c">% borrowing limit in ratio of aggregate output</span>
<span class="linenos">  8</span><span class="c">% Exogenous state variables</span>
<span class="linenos">  9</span><span class="k">var_shock</span> g d eta1;
<span class="linenos"> 10</span><span class="c">% Enumerate exogenous states and transition matrix</span>
<span class="linenos"> 11</span><span class="k">shock_num</span> = 8;
<span class="linenos"> 12</span>g = [.9904 1.0470 .9904 1.0470 .9904 1.0470 .9904 1.0470];
<span class="linenos"> 13</span>d = [.1402 .1437 .1561 .1599 .1402 .1437 .1561 .1599];
<span class="linenos"> 14</span>eta1 = [.3772 .3772 .3772 .3772 .6228 .6228 .6228 .6228];
<span class="linenos"> 15</span><span class="k">shock_trans</span> = [
<span class="linenos"> 16</span>    0.3932 0.2245 0.0793 0.0453 0.1365 0.0779 0.0275 0.0158
<span class="linenos"> 17</span>    0.3044 0.3470 0.0425 0.0484 0.1057 0.1205 0.0147 0.0168
<span class="linenos"> 18</span>    0.0484 0.0425 0.3470 0.3044 0.0168 0.0147 0.1205 0.1057
<span class="linenos"> 19</span>    0.0453 0.0793 0.2245 0.3932 0.0157 0.0275 0.0779 0.1366
<span class="linenos"> 20</span>    0.1366 0.0779 0.0275 0.0157 0.3932 0.2245 0.0793 0.0453
<span class="linenos"> 21</span>    0.1057 0.1205 0.0147 0.0168 0.3044 0.3470 0.0425 0.0484
<span class="linenos"> 22</span>    0.0168 0.0147 0.1205 0.1057 0.0484 0.0425 0.3470 0.3044
<span class="linenos"> 23</span>    0.0158 0.0275 0.0779 0.1365 0.0453 0.0793 0.2245 0.3932
<span class="linenos"> 24</span>    ];
<span class="linenos"> 25</span><span class="c">% Endogenous state variables</span>
<span class="linenos"> 26</span>var_state w1;  <span class="c">% wealth share</span>
<span class="linenos"> 27</span>w1 = linspace(-0.05,1.05,201);
<span class="linenos"> 28</span><span class="c">% Policy variables and bounds that enter the equations</span>
<span class="linenos"> 29</span><span class="k">var_policy</span> c1 c2 s1p nb1p nb2p ms1 ms2 mb1 mb2 ps pb;
<span class="linenos"> 30</span><span class="k">inbound</span> c1 0.05 1.0;
<span class="linenos"> 31</span><span class="k">inbound</span> c2 0.05 1.0;
<span class="linenos"> 32</span><span class="k">inbound</span> s1p 0.0 1.0;
<span class="linenos"> 33</span>inbound nb1p 0.0 1.0;   <span class="c">% nb1p=b1p-Kb</span>
<span class="linenos"> 34</span><span class="k">inbound</span> nb2p 0.0 1.0;   
<span class="linenos"> 35</span>inbound ms1 0 1;        <span class="c">% Multipliers for constraints</span>
<span class="linenos"> 36</span><span class="k">inbound</span> ms2 0 1;
<span class="linenos"> 37</span><span class="k">inbound</span> mb1 0 1;
<span class="linenos"> 38</span><span class="k">inbound</span> mb2 0 1;
<span class="linenos"> 39</span>inbound ps 0 3 <span class="k">adaptive</span>(1.5);
<span class="linenos"> 40</span>inbound pb 0 3 <span class="k">adaptive</span>(1.5);
<span class="linenos"> 41</span><span class="c">% Other policy variables</span>
<span class="linenos"> 42</span><span class="k">var_aux</span> equity_premium w1n[8];
<span class="linenos"> 43</span><span class="c">% Interpolation variables for policy and state transitions</span>
<span class="linenos"> 44</span><span class="k">var_interp</span> ps_future c1_future c2_future;
<span class="linenos"> 45</span><span class="k">initial</span> ps_future 0.0;
<span class="linenos"> 46</span><span class="k">initial</span> c1_future w1.*d+eta1;
<span class="linenos"> 47</span><span class="k">initial</span> c2_future (1-w1).*d+1-eta1;
<span class="linenos"> 48</span>ps_future = ps;
<span class="linenos"> 49</span>c1_future = c1;
<span class="linenos"> 50</span>c2_future = c2;
<span class="linenos"> 51</span>
<span class="linenos"> 52</span><span class="k">model;</span>
<span class="linenos"> 53</span>  <span class="c">% Transform bond back</span>
<span class="linenos"> 54</span>  b1p = nb1p + Kb;
<span class="linenos"> 55</span>  b2p = nb2p + Kb;
<span class="linenos"> 56</span>
<span class="linenos"> 57</span>  <span class="k">vector</span> w1nn[8];
<span class="linenos"> 58</span>  <span class="k">cxx;</span>
<span class="linenos"> 59</span>  for (int i_shock=1; i_shock&lt;=8; i_shock++)
<span class="linenos"> 60</span>  {
<span class="linenos"> 61</span>      <span class="k">auto</span> eval_consis_resid = [&amp;] (adouble w1_next)
<span class="linenos"> 62</span>      {
<span class="linenos"> 63</span>          <span class="k">auto</span> ps_next = ps_future_adouble(i_shock, w1_next);
<span class="linenos"> 64</span>          <span class="k">auto</span> total_share_value = ps_next + d_GRID(i_shock);
<span class="linenos"> 65</span>          <span class="k">auto</span> consis_resid = (s1p*total_share_value + b1p/g_GRID(i_shock)) / total_share_value - w1_next;
<span class="linenos"> 66</span>          return consis_resid;
<span class="linenos"> 67</span>      };
<span class="linenos"> 68</span>      
<span class="linenos"> 69</span>      
<span class="linenos"> 70</span>      <span class="k">const</span> double delta = 1e-6;
<span class="linenos"> 71</span>      <span class="k">const</span> double tol_eq = 1e-6;
<span class="linenos"> 72</span>      <span class="k">auto</span> funcd_eval_consis_resid = [&amp;] (adouble w1_next, adouble* df)
<span class="linenos"> 73</span>      {
<span class="linenos"> 74</span>          <span class="k">auto</span> consis_resid = eval_consis_resid(w1_next);
<span class="linenos"> 75</span>          <span class="k">auto</span> w1_next_plus = w1_next+delta;
<span class="linenos"> 76</span>          <span class="k">auto</span> consis_resid_plus = eval_consis_resid(w1_next_plus);
<span class="linenos"> 77</span>          *df = (consis_resid_plus - consis_resid) / (delta);
<span class="linenos"> 78</span>          return consis_resid;
<span class="linenos"> 79</span>      };
<span class="linenos"> 80</span>      
<span class="linenos"> 81</span>      <span class="k">const</span> double w1n_max = 1.5;
<span class="linenos"> 82</span>      <span class="k">const</span> double w1n_min = -0.5;
<span class="linenos"> 83</span>      a<span class="k">double</span> w1n0 = 0.5;
<span class="linenos"> 84</span>      w1nn(i_shock) = rtnewt(funcd_eval_consis_resid, w1n_min, w1n_max, w1n0, tol_eq);
<span class="linenos"> 85</span>  }
<span class="linenos"> 86</span>  end<span class="k">cxx;</span>
<span class="linenos"> 87</span>  w1n&#39; = w1nn&#39;; <span class="c">% Return the solution</span>
<span class="linenos"> 88</span>
<span class="linenos"> 89</span>  <span class="c">% Evaluate interpolation</span>
<span class="linenos"> 90</span>  [psn&#39;,c1n&#39;,c2n&#39;] = <span class="k">GDSGE_INTERP_VEC&#39;</span>(w1n&#39;);
<span class="linenos"> 91</span>  <span class="c">% Calculate expectations that enter the Euler Equations</span>
<span class="linenos"> 92</span>  es1_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c1n&#39;)^(-gamma)*(psn&#39;+d&#39;)};
<span class="linenos"> 93</span>  es2_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(1-gamma)*(c2n&#39;)^(-gamma)*(psn&#39;+d&#39;)};
<span class="linenos"> 94</span>  eb1_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c1n&#39;)^(-gamma)};
<span class="linenos"> 95</span>  eb2_future = <span class="k">GDSGE_EXPECT</span>{g&#39;^(-gamma)*(c2n&#39;)^(-gamma)};
<span class="linenos"> 96</span>  es1 = es1_future*c1^gamma/ps;
<span class="linenos"> 97</span>  es2 = es2_future*c2^gamma/ps;
<span class="linenos"> 98</span>  eb1 = eb1_future*c1^gamma/pb;
<span class="linenos"> 99</span>  eb2 = eb2_future*c2^gamma/pb;
<span class="linenos">100</span>
<span class="linenos">101</span>  <span class="c">% Market clearing of shares</span>
<span class="linenos">102</span>  s2p = 1-s1p;
<span class="linenos">103</span>  <span class="c">% Budget constraints</span>
<span class="linenos">104</span>  budget_1 = w1*(ps+d)+eta1 - c1 - ps*s1p - pb*b1p;
<span class="linenos">105</span>  budget_2 = (1-w1)*(ps+d)+(1-eta1) - c2 - ps*s2p - pb*b2p;
<span class="linenos">106</span>  <span class="c">% Consistency equations</span>
<span class="linenos">107</span>  w1_consis&#39; = (s1p*(psn&#39;+d&#39;) + b1p/g&#39;)/(psn&#39;+d&#39;) - w1n&#39;;
<span class="linenos">108</span>  <span class="c">% Other policy variables</span>
<span class="linenos">109</span>  equity_premium = <span class="k">GDSGE_EXPECT</span>{(psn&#39;+d&#39;)/ps*g&#39;} - 1/pb;
<span class="linenos">110</span>  <span class="k">equations;</span>
<span class="linenos">111</span>    -1+beta*es1+ms1;
<span class="linenos">112</span>    -1+beta*es2+ms2;
<span class="linenos">113</span>    -1+beta*eb1+mb1;
<span class="linenos">114</span>    -1+beta*eb2+mb2;
<span class="linenos">115</span>    ms1*s1p;
<span class="linenos">116</span>    ms2*s2p;
<span class="linenos">117</span>    mb1*nb1p;
<span class="linenos">118</span>    mb2*nb2p;
<span class="linenos">119</span>    b1p+b2p;
<span class="linenos">120</span>    budget_1/w1;        <span class="c">% Normalized by total budget</span>
<span class="linenos">121</span>    budget_2/(1-w1);
<span class="linenos">122</span>  <span class="k">end;</span>
<span class="linenos">123</span><span class="k">end;</span>
<span class="linenos">124</span>
<span class="linenos">125</span><span class="k">simulate;</span>
<span class="linenos">126</span>  <span class="k">num_periods</span> = 10000;
<span class="linenos">127</span>  <span class="k">num_samples</span> = 6;
<span class="linenos">128</span>  <span class="k">initial</span> w1 0.5;
<span class="linenos">129</span>  <span class="k">initial</span> shock 1;
<span class="linenos">130</span>  <span class="k">var_simu</span> c1 c2 ps pb equity_premium ms1 mb1;
<span class="linenos">131</span>  w1&#39; = w1n&#39;;
<span class="linenos">132</span><span class="k">end;</span>
</pre></div>
</div>
<p>As shown, Line 57-87 of the modified code is used to solve the inner problem, and codes for the equation solver need to be “included” (by Line 1 and 2, download the included file
<a class="reference download internal" download="" href="../../_downloads/63e330054658679dc25944737fe283c4/rtnewt.h"><code class="xref download docutils literal notranslate"><span class="pre">here</span></code></a>).
The <em>cxx;</em> block is essentially a hack implemented by the toolbox to insert a block of raw C++ codes. The block here defines the inner problem
(the inner lambda function eval_consis_resid defined starting at Line 61),
which is a single-unknown equation for the future state variable given current policies, and calls the solver to solve the problem, for each future state. The Newton solver, used here,
achieves high performance but requires a delicate choice of the initial point for the inner problem.
The choice of the initial point of 0.5, guarantees that the solutions can be found across the state space and time iterations, with
values of policy variables not
too distant from the equilibrium ones.</p>
<p>Although doable, inserting add-hoc C++ codes like this tends to be inconvenient and err-prone, and thus not recommended to regular researchers.
This example makes it clear why designing an interface that accommodates add-hoc nested algorithms is difficult, whereas it can be made with the STPFI algorithm.</p>
<p>Finally, the existence of the nested problem breaks the efficient automatic differentiation for calculating the Jacobian Matrix of the outer problem,
since the nested problem needs to use an iterative solver that is not amenable to efficient automatic differentiation.
As shown in Table R1 and discussed above, the inner problem requires substantially more number of evaluations of consistency equation (eval_consis_resid),
which require repeatedly calling the interpolation procedure to evaluate future share prices at <em>off-equilibrium</em> wealth shares (Line 63).
This makes the algorithm not as performanent as the STPFI.</p>
</section>
</section>
<section id="what-s-next">
<h2>What’s Next?<a class="headerlink" href="#what-s-next" title="Permalink to this heading"></a></h2>
<p>Through this simple example, you understand the power of the toolbox and all the essential ingredients to solve
a modern macro model.</p>
<p>For the time-iteration algorithm to work robustly, a crucial step is to define the starting point of the iteration
properly. A candidate that delivers good theoretical property and proves to be numerically stable is to start from a last-period problem,
so the algorithm can be viewed as taking the limit of the solution from finite-horizon iterations (<a class="reference external" href="https://www.jstor.org/stable/2951731">Duffie et al (1994)</a>; <a class="reference external" href="https://www.jstor.org/stable/2951735">Magill and Quinzi (1994)</a>; <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0022053119301255">Cao (2020)</a>).</p>
<p>The last-period problem has been so far trivial in the <a class="reference internal" href="../rbc/rbc.html#getting-started-a-simple-rbc-model"><span class="std std-ref">RBC model</span></a> and <a class="reference external" href="https://www.journals.uchicago.edu/doi/10.1086/262030">Heaton and Lucas (1996)</a> examples,
but could turn out to be more complex
and requires to define a different system of equations than the main <em>model;</em> block. Also, at the boundary of the state space,
the equilibrium may be characterized by a different system of equations, and such boundary conditions turn out to be necessary to solve
many models robustly (for example, consumption might be exactly zero at the boundary, violating the Inada condition). To see how these issues are addressed very conveniently in the toolbox, see example
<a class="reference internal" href="../KM1997/CaoNie2017.html#caonie2017"><span class="std std-ref">Cao and Nie (2017)</span></a>.</p>
<p>Or you can directly proceed to <a class="reference internal" href="../../usage/functions.html#toolbox-api"><span class="std std-ref">the toolbox’s API</span></a>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../rbc/rbcIrr.html" class="btn btn-neutral float-left" title="An RBC Model with Irreversible Investment" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../Guvenen2009/Guvenen2009.html" class="btn btn-neutral float-right" title="Guvenen (2009): Asset Pricing with Heterogeneous IES" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Dan Cao, Wenlan Luo, and Guangyu Nie.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>